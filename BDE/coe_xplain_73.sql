/*$Header: coe_xplain_73.sql 7.3 156960.1 2002/09/03            csierra coe $*/
SET term off ver off trims on;
/*=============================================================================

coe_xplain_73.sql - Enhanced Explain Plan For Given SQL Statement (7.3)

    *************************************************************
    This article is being delivered in Draft form and may contain
    errors.  Please use the MetaLink "Feedback" button to advise
    Oracle of any issues related to this article.
    *************************************************************


 Overview
 --------

    coe_xplain_73.sql generates an Enhanced Explain Plan for one SQL statement
    to diagnose apps performance issues.

    It includes relevant statistics for tables, indexes and columns.

    It displays storage parameters and database parameters.

    It also produces a CBO trace.


 Instructions
 ------------

 1. Copy this whole Note into a text file.  Name it coe_xplain_73.sql when
    saving your text file.  Be sure filename is coe_xplain_73.sql.

 2. Create a flat file with one SQL statement for which you want to generate
    its explain plan.  Name this text file sql.txt.  It should have one and
    only one SQL statement.  Your SQL statement should NOT have a semicolon at
    the end.  It should end with either a space, or a single blank line.

    The space at the end is because in some environments, the last character
    of the SQL statement in sql.txt gets truncated, so if you add a space ' '
    or a single blank line at the end, your SQL statement will be still
    complete.  Do not include more than one single blank line at the end.

 3. There is no need to remove any bind variable from your SQL statement.  Do
    not replace bind variables with literals either.

 4. Save your sql.txt file.  Name of text file is not hardcoded, therefore you
    can use sql1.txt, sql2.txt and so on.

 5. Place coe_xplain_73.sql and sql.txt flat files into same dedicated
    directory.

    coe_xplain_73.sql will try to open sql.txt under same directory.

 6. Execute coe_xplain_73.sql from SQL*Plus connected as user with access to
    all objects referenced by SQL statement in sql.txt.

    If you are using coe_xplain_73.sql within an Apps instance, connect as
    APPS, otherwise connect as corresponding user with access to all objects
    referenced by SQL statement:

    # sqlplus apps/apps@vis107

    SQL> START coe_xplain_73.sql sql.txt;

 7. Review output files (spool): COE_XPLAIN_SQL.TXT and COE_STATEMENT_SQL.TXT

    The spool files get created on same directory from which coe_xplain_73.sql
    is executed.  SQL.TXT suffix represents filename provided in parameter 1.
    On NT, files may get created under $ORACLE_HOME/bin.

 8. Provide to Support spool files compressed into a *.zip file according to
    instructions at the end of the generated COE_XPLAIN_SQL.TXT file.

 9. If requested, provide also raw SQL Trace generated by the script.


 Program Notes
 -------------

 1. Always download latest version from Metalink (Note:156960.1), or ftp from

    ftp://oracle-ftp.oracle.com/apps/patchsets/AOL/SCRIPTS/PERFORMANCE/

    In order to avoid cut and paste or word wraping issues, use better ftp

 2. The Explain Plan is spooled to file COE_XPLAIN_SQL.TXT.

    The original SQL statement is spooled to COE_STATEMENT_SQL.TXT

    SQL.TXT suffix represents filename provided in parameter 1.

 3. If you need to ftp spool files from UNIX to any other system, use ASCII.

 4. Open the spooled files using WordPad, change the font to Courier New, style
    regular and size 8.  Set up the page to Lanscape with all 4 margins 0.2 in.

 5. This script has been tested up to Oracle Apps 10.7 with Oracle 7.3.4.

 6. Selectivity mismatch was reported on internal Bug fixed on 9.0.0.

 7. Personalize replacing all XYZ with initials to avoid collisions under a
    concurrent environment (i.e. during training), otherwise don't replace.

 8. For Oracle 8.1 (8i) use coe_xplain.sql from Note:156958.1

    For Oracle 8.0 use coe_xplain_80.sql from Note:156959.1

    For Oracle 7.3 use coe_xplain_73.sql from Note:156960.1

 9. For other SQL Tuning scripts, search on Metalink using keyword coescripts.

10. A practical guide in Troubleshooting Oracle ERP Applications Performance
    Issues can be found on Metalink under Note:169935.1


 Parameters
 ----------

    coe_xplain_73.sql requires one user parameter to specify the name of the
    file containing the SQL statement to be explained.  This parameter is
    passed on the same command line used to execute coe_xplain_73.sql.

    # sqlplus apps/apps@vis107

    SQL> START coe_xplain_73.sql sql.txt;

    coe_xplain_73.sql includes also 3 fixed or seeded parameters.  They should
    only be changed if requested by Support.  They have been seeded with
    default values below.

 1. Include count(*) of Tables? [Y]

        Y - Creates and runs a SQL script to perform a count(*) on all Tables
            referenced in the Explain Plan.  It may be slow but it is highly
            recommended, specially for RULE based optimizer (DEFAULT)

        N - Does not display count(*) information for all Tables

 2. Include Segment Extents? [N]

        N - Skips the display of Segment Extents (DEFAULT)

        Y - Displays counts and summarizes of Segment Extents for each Object
            referenced in Explain Plan.  This step may be very slow.
            Request this detailed option only when really needed.

 3. Include all Table Columns? [Y]

        Y - Extracts and displays all Columns for all Tables referenced in
            Explain Plan (DEFAULT)

        N - Displays statistics only for those Columns included in at least
            one Index of a Table referenced in the Explain Plan


 Caution
 -------

    The sample program in this article is provided for educational purposes
    only and is NOT supported by Oracle Support Services.  It has been tested
    internally, however, and works as documented.  We do not guarantee that it
    will work for you, so be sure to test it in your environment before
    relying on it.


 Portal
 ------

    Abstract: coe_xplain_73.sql - Enhanced Explain Plan For Given SQL Statement
    Author: Carlos Sierra
    Date: 03-SEP-02
    Description: Non-intrusive SQL Tuning tool to diagnose performance issues
    EMail: carlos.sierra@oracle.com
    Internal_Only: N
    Keywords: coe_stattab.sql explainplan sqltuning coescripts appsperf
    Metalink_Note: 156960.1
    New_Win: Y
    Product: SQL*Plus script
    Version: 7.3 2002/09/03
    Download: coe_xplain_73.zip

   ========================================================================= */
/* I. Execution Parameters Section
   ========================================================================= */
SET term on ver off trims on;
PROMPT
PROMPT ========================================================================
PROMPT coe_xplain_73.sql - Enhanced Explain Plan for given SQL statement (7.3)
PROMPT ========================================================================
PROMPT
PROMPT Parameter 1 specifies filename of flat file containing SQL statement
PROMPT
SET term off;

/* if you want to enable user parameters, remove two comment lines (this line
   and this one).  Remove line after 3rd accept, and remove 3 define commands.
SET term on;
PROMPT Unless otherwise instructed by Support, hit <Enter> at each parameter.
PROMPT All parameters will default to value in brackets.  Valid values: Y or N.
PROMPT
accept include_count       prompt '1. Include count(*) of Tables? [Y] ';
accept include_extents     prompt '2. Include Segment Extents?    [N] ';
accept include_all_columns prompt '3. Include all Table Columns?  [Y] ';
*/

define include_count       = Y;
define include_extents     = N;
define include_all_columns = Y;

/* II. DDL Section - Create COE Temporary Tables
   ========================================================================= */
DROP   TABLE COE_PLAN_TABLE_XYZ;
CREATE TABLE COE_PLAN_TABLE_XYZ
    (statement_id varchar2(30),timestamp date,remarks varchar2(80),
     operation varchar2(30),options varchar2(30),object_node varchar2(128),
     object_owner varchar2(30),object_name varchar2(30),
     object_instance numeric,object_type varchar2(30),
     optimizer varchar2(255),search_columns number,id numeric,
     parent_id numeric,position numeric,cost numeric,cardinality numeric,
     bytes numeric,other_tag varchar2(255),partition_start varchar2(255),
     partition_stop varchar2(255),partition_id numeric,other long,
     distribution varchar2(30),execution_order numeric);
DROP   TABLE COE_JOIN_ORDER_XYZ;
CREATE TABLE COE_JOIN_ORDER_XYZ
    (EXECUTION_ORDER_T NUMERIC,EXECUTION_ORDER_I NUMERIC,
     TABLE_NAME VARCHAR2(30),TABLE_ONLY VARCHAR2(3),INDEX_ONLY VARCHAR2(3),
     INDEX_METHOD VARCHAR2(50));
DROP   TABLE COE_TABLES_XYZ;
CREATE TABLE COE_TABLES_XYZ
    (TABLE_OWNER VARCHAR2(30),TABLE_NAME VARCHAR2(30),TABLE_NUM NUMBER,
     ROWS_COUNT NUMBER,PARTITIONED VARCHAR2(3),PERCENT NUMBER);
DROP   TABLE COE_INDEXES_XYZ;
CREATE TABLE COE_INDEXES_XYZ
    (TABLE_OWNER VARCHAR2(30),TABLE_NAME VARCHAR2(30),TABLE_NUM NUMBER,
     INDEX_OWNER VARCHAR2(30),INDEX_NAME VARCHAR2(30),INDEX_NUM NUMBER,
     PARTITIONED VARCHAR2(3));

/* III. Generate Explain Plan Section
   ========================================================================= */
alter session set events '10053 trace name context forever, level 1';
SET pages 1000 lin 156 sqlp '' sqln off autotrace off term on;
SPOOL coe_statement_&&1;
PROMPT ========================================================================
PROMPT Generating Enhanced Explain Plan for SQL statement on file &&1
PROMPT ========================================================================
get &&1
0 explain plan set statement_id = 'COE_XPLAIN' into COE_PLAN_TABLE_XYZ for
/
/* ========================================================================= */
SET echo off;
SPOOL OFF;
PROMPT Computing Execution Order...
SET term off;
alter session set events '10053 trace name context off';

/* IV. Compute Execution Order Section
   ========================================================================= */
DECLARE
    coe_pointer     number := 0;  -- Row on COE_PLAN_TABLE being processed.
    coe_next_order  number := 1;  -- To update Execution Order
    coe_xplain      CONSTANT varchar2(30) := 'COE_XPLAIN'; -- statement_id.
    coe_parent_id   number;       -- To move pointer (only if needed).
    coe_curr_order  varchar2(80); -- Order in current row of COE_PLAN_TABLE.
    coe_count_child number;       -- Number of children for a parent.
BEGIN
    LOOP
        SELECT parent_id, execution_order    -- Reads COE_PLAN_TABLE w/pointer.
        INTO   coe_parent_id, coe_curr_order -- Starts on first row (id=0) and
        FROM   COE_PLAN_TABLE_XYZ            -- works its way down.
        WHERE  id           = coe_pointer
        AND    statement_id = coe_xplain;
        IF  coe_curr_order is not null THEN  -- When row has already its Order:
            EXIT WHEN coe_pointer = 0;       -- Exit Loop if back at the Top.
            coe_pointer := coe_parent_id;    -- Else, move pointer to parent.
        ELSE                                 -- When doesn't have Order yet:
            SELECT count(*)                  -- Determines if there is any
            INTO   coe_count_child           -- child for the current parent
            FROM   COE_PLAN_TABLE_XYZ        -- pending to receive Order.
            WHERE  parent_id        = coe_pointer
            AND    execution_order is null
            AND    statement_id     = coe_xplain;
            IF  coe_count_child     = 0 THEN -- If no child is pending:
                UPDATE COE_PLAN_TABLE_XYZ    -- row gets new Order.
                SET execution_order = to_char(coe_next_order)
                WHERE  id           = coe_pointer
                AND    statement_id = coe_xplain;
                coe_next_order := coe_next_order + 1; -- Order gets increm.
            ELSE                             -- If at least one pending child:
                SELECT id                    -- Move pointer to first pending
                INTO   coe_pointer           -- child.
                FROM   COE_PLAN_TABLE_XYZ
                WHERE  parent_id        = coe_pointer
                AND    execution_order is null
                AND    rownum           = 1
                AND    statement_id     = coe_xplain;
            END IF;
        END IF;
    END LOOP;
END;
/

/* V. COLUMN Definition Section
   ========================================================================= */
SET feed off;
SET numf 999,999,999;
CLEAR columns;
CLEAR breaks;
VARIABLE cbo_plan number;
COLUMN typ FORMAT a3 HEADING 'Ope|Typ';
COLUMN execution_order FORMAT 9999 HEADING 'Exec|Order';
COLUMN execution_order_t FORMAT b9999 HEADING 'Exec|Order|Table';
COLUMN execution_order_i FORMAT b9999 HEADING 'Exec|Order|Index';
COLUMN table_only FORMAT a5 HEADING 'Table|Only';
COLUMN index_only FORMAT a5 HEADING 'Index|Only';
COLUMN index_method FORMAT a50 HEADING 'Table/Index Access Method';
COLUMN table_name_j FORMAT a30 HEADING 'Tables by Join Order';
COLUMN query_plan FORMAT a140 HEADING -
       'Explain Plan by coe_xplain_73.sql 7.3 2002/09/03 Note:156960.1' wor;
COLUMN owner_table FORMAT a37 HEADING 'Owner.Table';
COLUMN owner_index FORMAT a40 HEADING 'Owner.Index';
COLUMN table_name FORMAT a30 HEADING 'Table';
COLUMN index_name FORMAT a33 HEADING 'Index';
COLUMN last_analyzed FORMAT a15 HEADING 'Last|Analyzed';
COLUMN num_rows FORMAT b99,999,999.999 HEADING -
                    '(B)|Num of rows|in Table|(Cardinality)';
COLUMN num_rows_p FORMAT b99,999,999.999 HEADING -
                    '(J)|Num of rows|in Partition|(Cardinality)';
COLUMN num_rows_i FORMAT b99,999,999.999 HEADING -
                    '(C)|Number|of rows|in Index';
COLUMN num_rows_ip FORMAT b99,999,999.999 HEADING -
                    '(C)|Number|of rows|in Partition';
COLUMN delta_percent FORMAT b999,999.9 HEADING 'Delta|Percent|ABS(A-B)/A';
COLUMN avg_row_len FORMAT b99,999 HEADING 'Avg Row|Length|(bytes)';
COLUMN avg_col_len FORMAT b99,999 HEADING 'Avg Col|Length|(bytes)';
COLUMN num_buckets FORMAT b99,999 HEADING 'Number|Buckets|Histogr';
COLUMN hwm_blocks FORMAT b99,999,999 HEADING 'High|Water-Mark|(blocks)';
COLUMN empty_blocks FORMAT b99,999,999 HEADING 'Empty|Blocks';
COLUMN used_blocks FORMAT b99,999,999 HEADING 'Used|Blocks';
COLUMN freelists FORMAT b99 HEADING 'Free|Lists';
COLUMN global_stats FORMAT a6 HEADING 'Global|Stats';
COLUMN distinct_keys FORMAT b99,999,999 HEADING '(D)|Distinct|Keys';
COLUMN num_distinct FORMAT b99,999,999 HEADING '(H)|Num of|Distinct|Values';
COLUMN rows_count FORMAT b999,999,999 HEADING '(A)|Rows from|Count(*)';
COLUMN index_cardinality FORMAT 999,999,999 HEADING -
                    '(E)|Computed|Index|Cardinality|CEIL(C/D)';
COLUMN index_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Index|Selectivity|((C/D)/B)';
COLUMN part_cardinality FORMAT 999,999,999 HEADING -
                    '(E)|Computed|Partition|Cardinality|CEIL(C/D)';
COLUMN part_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Partition|Selectivity|((C/D)/B)';
COLUMN column_cardinality FORMAT 999,999,999 HEADING -
                    '(I)|Computed|Column|Cardinality|CEIL(G/H)';
COLUMN column_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Column|Selectivity|((G/H)/B)';
COLUMN density FORMAT b9.9999eeee HEADING -
                    'Column|Density|from Data|Dictionary';
COLUMN column_selectivity_2 FORMAT b9.9999eeee HEADING -
                    '(K)|Computed|Column|Selectivity|((G/H)/B)';
COLUMN density_2 FORMAT b9.9999eeee HEADING -
                    '(L)|Column|Density|from Data|Dictionary';
COLUMN density_mismatch FORMAT b9.999999 HEADING -
                    'Selectivity|Mismatch|(L-K)';
COLUMN table_num FORMAT 99 HEADING 'Tab|Num';
COLUMN index_num FORMAT 999 HEADING 'Indx|Num';
COLUMN uniqueness FORMAT a10 HEADING 'Uniqueness';
COLUMN column_name FORMAT a30 HEADING 'Column';
COLUMN column_position FORMAT 999 HEADING 'Pos';
COLUMN nullable FORMAT a9 HEADING 'Null?';
COLUMN num_nulls FORMAT 99,999,999 HEADING -
                    '(F)|Number of|Rows with|NULLs in|this column';
COLUMN not_nulls FORMAT 99,999,999 HEADING -
                    '(G)|Number of|Rows with|Value|(B-F)';
COLUMN not_nulls_p FORMAT 99,999,999 HEADING -
                    '(G)|Number of|Rows with|Value|(J-F)';
COLUMN avg_space FORMAT b9,999,999,999 HEADING -
                    'Average|free space|per allocated|block (bytes)';
COLUMN avg_space_percent FORMAT b99,999,999.9 HEADING -
                    'Average|free space|per allocated|block (%)';
COLUMN degree FORMAT b99,999 HEADING 'Degree|of Para-|llelism';
COLUMN partitioned FORMAT a7 HEADING 'Parti-|tioned?';
COLUMN sample_size FORMAT b999,999,999 HEADING 'Sample|Size|(% or|rows)';
COLUMN chain_cnt FORMAT 99,999,999 HEADING 'Chain|Count|(rows)';
COLUMN tablespace_name FORMAT a25 HEADING 'Tablespace';
COLUMN pct_free FORMAT b999 HEADING -
                    'Minimum|percent of|free space|per block|(pct_free)';
COLUMN pct_used FORMAT b999 HEADING -
                    'Minimum|percent of|used space|per block|(pct_used)';
COLUMN initial_extent FORMAT b999,999,999,999 HEADING -
                    'Initial|Extent|size|(bytes)';
COLUMN next_extent FORMAT b999,999,999,999 HEADING -
                    'Next|Extent|size|(bytes)';
COLUMN min_extents FORMAT b999,999 HEADING 'Minimum|num. of|Extents';
COLUMN max_extents FORMAT b9,999,999,999 HEADING 'Maximum num.|of Extents';
COLUMN pct_increase FORMAT b99,999 HEADING -
                    'Percent|increase|size for|Next|Extent';
COLUMN count_extents FORMAT b99,999 HEADING 'Actual|Extents|Count';
COLUMN index_type FORMAT a12 HEADING 'Index Type';
COLUMN status FORMAT a10 HEADING 'Status';
COLUMN blevel FORMAT 999,999 HEADING 'B*-Tree|level|(index|depth)';
COLUMN leaf_blocks FORMAT 9,999,999 HEADING 'Number|of|leaf|blocks';
COLUMN avg_leaf_blocks_per_key FORMAT 9,999,999 HEADING -
                    'Avg num of|leaf blocks|per key';
COLUMN avg_data_blocks_per_key FORMAT 9,999,999 HEADING -
                    'Avg Num of|data blocks|per key';
COLUMN clustering_factor FORMAT 999,999,999 HEADING 'Clustering|factor';
COLUMN data_type FORMAT a14 HEADING 'Type';
COLUMN column_id FORMAT 9999 HEADING 'Col';
COLUMN extent_id FORMAT 999999999 HEADING 'Extent ID';
COLUMN file_id FORMAT 9999999 HEADING 'File ID';
COLUMN block_id FORMAT 9999999999 HEADING 'Block ID|from';
COLUMN block_to FORMAT 9999999999 HEADING 'Block ID|to';
COLUMN blocks FORMAT 99,999,999 HEADING 'Blocks';
COLUMN bytes FORMAT 999,999,999,999 HEADING 'Bytes';
COLUMN pname FORMAT a33 HEADING 'Parameter Name';
COLUMN pvalue FORMAT a115 HEADING 'Parameter Value';
COLUMN object_id FORMAT 999999 HEADING 'Object';
COLUMN indexed_column FORMAT a7 HEADING 'Indexed|Column';
COLUMN endpoint_number FORMAT 999999 HEADING 'Bucket|Number';
COLUMN endpoint_value FORMAT B999999999999 HEADING -
                    'Normalized|end point|numeric|value';
COLUMN endpoint_value_e FORMAT b9.999999eeee HEADING -
                    'Normalized|end point|numeric|value (e10)';
COLUMN endpoint_value_d FORMAT a12 HEADING -
                    'Normalized|end point|numeric|value (date)';
COLUMN endpoint_actual_value FORMAT a30 HEADING -
                    'Normalized|end point|actual|value';
COLUMN partition FORMAT a30 HEADING -
                    'Partition according to|FND_HISTOGRAM_COLS';
COLUMN hsize FORMAT 9999999 HEADING 'Num. of|Buckets|(max)';
COLUMN partition_position FORMAT 9999 HEADING 'Part|Pos';
COLUMN partition_name FORMAT a30 HEADING 'Partition Name';
COLUMN composite FORMAT a9 HEADING 'Composite';
COLUMN subpartition_count FORMAT 9999999 HEADING 'Subpart|Count';
COLUMN high_value FORMAT a50 HEADING 'Partition High Value';
COLUMN compression FORMAT a11 HEADING 'Key|Compression';
COLUMN product FORMAT a30 HEADING 'Installed Products';
COLUMN version FORMAT a12 HEADING 'Version';
COLUMN ended FORMAT A23 HEADING 'coe_xplain_73.sql ended';

/* VI. Populate COE Temporary Tables Section
   ========================================================================= */
INSERT
    INTO COE_JOIN_ORDER_XYZ
SELECT                        -- Table and Index, or Table Only
    CPT.EXECUTION_ORDER,      -- EXECUTION_ORDER_T
    NVL(CHILD.EXECUTION_ORDER,0),
                              -- EXECUTION_ORDER_I
    CPT.OBJECT_NAME,          -- TABLE_NAME
    DECODE(CHILD.OBJECT_NAME,NULL,'YES',NULL),
                              -- TABLE_ONLY
    NULL,                     -- INDEX_ONLY
    DECODE(CHILD.OBJECT_NAME,NULL,'('||CPT.OPTIONS||')',
           CHILD.OBJECT_NAME||' ('||CHILD.OPTIONS||')')
                              -- INDEX_METHOD
FROM
    COE_PLAN_TABLE_XYZ CHILD,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.ID                               = CHILD.PARENT_ID(+)
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'TABLE ACCESS'
AND NVL(CHILD.STATEMENT_ID,'COE_XPLAIN') = 'COE_XPLAIN'
AND NVL(CHILD.OPERATION,'INDEX')         = 'INDEX'
UNION ALL
SELECT                        -- Index Only
    0,                        -- EXECUTION_ORDER_T
    CPT.EXECUTION_ORDER,      -- EXECUTION_ORDER_I
    AI.TABLE_NAME,            -- TABLE_NAME
    NULL,                     -- TABLE_ONLY
    'YES',                    -- INDEX_ONLY
    CPT.OBJECT_NAME||' ('||CPT.OPTIONS||')'
                              -- INDEX_METHOD
FROM
    ALL_INDEXES    AI,
    COE_PLAN_TABLE_XYZ PARENT,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.PARENT_ID                        = PARENT.ID
AND CPT.OBJECT_OWNER                     = AI.OWNER
AND CPT.OBJECT_NAME                      = AI.INDEX_NAME
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'INDEX'
AND PARENT.STATEMENT_ID                  = 'COE_XPLAIN'
AND PARENT.OPERATION                    <> 'TABLE ACCESS'
AND PARENT.OPERATION                    <> 'AND-EQUAL'
UNION ALL
SELECT                        -- AND-EQUAL
    PARENT.EXECUTION_ORDER,   -- EXECUTION_ORDER_T
    CHILD.EXECUTION_ORDER,    -- EXECUTION_ORDER_I
    PARENT.OBJECT_NAME,       -- TABLE_NAME
    NULL,                     -- TABLE_ONLY
    NULL,                     -- INDEX_ONLY
    CHILD.OBJECT_NAME||' ('||CHILD.OPTIONS||')'
                              -- INDEX_METHOD
FROM
    COE_PLAN_TABLE_XYZ CHILD,
    COE_PLAN_TABLE_XYZ PARENT,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.PARENT_ID                        = PARENT.ID
AND CPT.ID                               = CHILD.PARENT_ID
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'AND-EQUAL'
AND PARENT.STATEMENT_ID                  = 'COE_XPLAIN'
AND PARENT.OPERATION                     = 'TABLE ACCESS'
AND CHILD.STATEMENT_ID                   = 'COE_XPLAIN'
AND CHILD.OPERATION                      = 'INDEX';

INSERT
    INTO COE_TABLES_XYZ
SELECT
    OBJECT_OWNER, -- TABLE_OWNER
    OBJECT_NAME,  -- TABLE_NAME
    NULL,         -- TABLE_NUM
    NULL,         -- ROWS_COUNT
    'NO',         -- PARTITIONED
    NULL          -- PERCENT
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID = 'COE_XPLAIN'
and OPERATION    = 'TABLE ACCESS'
UNION
SELECT
    TABLE_OWNER, -- TABLE_OWNER
    TABLE_NAME,  -- TABLE_NAME
    NULL,        -- TABLE_NUM
    NULL,        -- ROWS_COUNT
    'NO',        -- PARTITIONED
    NULL         -- PERCENT
FROM
    ALL_INDEXES
WHERE
    (OWNER,
     INDEX_NAME)
IN  (SELECT DISTINCT
         OBJECT_OWNER,
         OBJECT_NAME
     FROM
         COE_PLAN_TABLE_XYZ
     WHERE
         STATEMENT_ID = 'COE_XPLAIN'
     and OPERATION    = 'INDEX');

UPDATE
    COE_TABLES_XYZ
SET
    TABLE_NUM = ROWNUM;

UPDATE
    COE_TABLES_XYZ CT
SET
    PARTITIONED = (SELECT PARTITIONED FROM ALL_TABLES AT
                   WHERE  AT.OWNER      = CT.TABLE_OWNER
                   AND    AT.TABLE_NAME = CT.TABLE_NAME);

UPDATE
    COE_TABLES_XYZ CT
SET
    PERCENT =
    (SELECT
       DECODE(NVL(AT.NUM_ROWS,0),0,10,                  -- NULL or 0 (10%)
       DECODE(SIGN(AT.NUM_ROWS-    10000),-1,99.999999, -- 1-10K (100%)
       DECODE(SIGN(AT.NUM_ROWS-   100000),-1,16,        -- 10K-100K (16%)
       DECODE(SIGN(AT.NUM_ROWS-  1000000),-1,12,        -- 100K-1M (12%)
       DECODE(SIGN(AT.NUM_ROWS- 10000000),-1,8,         -- 1M-10M (8%)
       DECODE(SIGN(AT.NUM_ROWS-100000000),-1,4,2))))))  -- 10M-100M (4%)
     FROM ALL_TABLES AT                                 -- >100M (2%)
     WHERE AT.OWNER      = CT.TABLE_OWNER
     AND   AT.TABLE_NAME = CT.TABLE_NAME);

INSERT
    INTO COE_INDEXES_XYZ
SELECT DISTINCT
    CT.TABLE_OWNER, -- TABLE_OWNER
    CT.TABLE_NAME,  -- TABLE_NAME
    CT.TABLE_NUM,   -- TABLE_NUM
    AI.OWNER,       -- INDEX_OWNER
    AI.INDEX_NAME,  -- INDEX_NAME
    NULL,           -- INDEX_NUM
    'NO'            -- PARTITIONED
FROM
    ALL_INDEXES        AI,
    COE_TABLES_XYZ     CT
WHERE
    CT.TABLE_OWNER   = AI.TABLE_OWNER
AND CT.TABLE_NAME    = AI.TABLE_NAME;

UPDATE
    COE_INDEXES_XYZ
SET
    INDEX_NUM = ROWNUM;

UPDATE
    COE_INDEXES_XYZ CI
SET
    PARTITIONED = (SELECT PARTITIONED FROM ALL_INDEXES AI
                   WHERE  AI.OWNER      = CI.INDEX_OWNER
                   AND    AI.INDEX_NAME = CI.INDEX_NAME);

SET hea off;
SET pages 0;
SET lin 300;
SPOOL coe_xplain_tables.sql;
SELECT
    'UPDATE COE_TABLES_XYZ CT SET ROWS_COUNT=(SELECT '||
    'COUNT(*) FROM '||TABLE_OWNER||'.'||TABLE_NAME||
    ') WHERE CT.TABLE_OWNER='''||
    TABLE_OWNER||''' AND CT.TABLE_NAME='''||TABLE_NAME||''';'
FROM
    COE_TABLES_XYZ
WHERE
    NVL(substr(upper('&&include_count'),1,1),'Y') = 'Y';
SPOOL OFF;
START coe_xplain_tables.sql;

COMMIT;

/* VII. Creates coe_xplain_sql.txt spool file with Explain Plan
   ========================================================================= */
SET hea on pages 10000;
SPOOL coe_xplain_&&1;
SET lin 156 long 50 term on recsep off;

PROMPT ========================================================================
PROMPT coe_xplain_73.sql - Enhanced Explain Plan For Given SQL Statement (7.3)
PROMPT ========================================================================
get &&1

SELECT -- VII. Creates coe_xplain_&&1 spool file with Explain Plan (1st)
    DECODE(OPERATION,'SORT','SET','HASH JOIN','S/R','ROW') typ,  -- Op Type
    EXECUTION_ORDER, -- Processing Order
    lpad(' ',LEVEL+1,rpad(' ',80,'....|'))||OPERATION||' '|| -- Operation
    DECODE(OPTIONS,NULL,'',DECODE(SUBSTR(OPTIONS,1,4),'FULL',
           '***('||OPTIONS||')*** ','('||OPTIONS||') '))|| -- Options
    DECODE(OBJECT_OWNER,null,'','OF '''||OBJECT_OWNER||'.')|| -- Owner
    DECODE(OBJECT_NAME,null,'',OBJECT_NAME||''' ')|| -- Object Name
    DECODE(OBJECT_TYPE,null,'','('||OBJECT_TYPE||') ')|| -- Object Type
    DECODE(ID,0,'Opt_Mode:')||
    DECODE(OPTIMIZER,null,'','ANALYZED','',OPTIMIZER)
    query_plan -- Explain Plan
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID    = 'COE_XPLAIN'
CONNECT BY PRIOR ID = PARENT_ID
AND STATEMENT_ID    = 'COE_XPLAIN'
START WITH ID       = 0
AND STATEMENT_ID    = 'COE_XPLAIN'
ORDER BY ID,POSITION;

/* VII.a Displays CBO Extended Plan if CBO has been used                     */
/* ========================================================================= */
BEGIN
    select count(*) into :CBO_PLAN from COE_PLAN_TABLE_XYZ
    where cost is not null;
END;
/
Rem $Header: utlxplp.sql 25-may-98.16:30:41 bdagevil Exp $ CBO Extended Plan
select '|Exec'||
    '| Operation                         |  Object Name               '||
    '|  Rows | Bytes|  Cost  |  TQ  '||
    '|IN-OUT| PQ Distrib | Pstart| Pstop |'
as "CBO Extended Plan"
from dual
where :CBO_PLAN > 0
union all
select '------------------------------'||
    '-----------------------------------------------------------------------'||
    '-------------------------------------'
from dual
where :CBO_PLAN > 0
union all
select '|'||lpad(execution_order,4,' ')||
    rpad('| '||substr(lpad(' ',1*(level-1))||operation||
    decode(options, null,'',' '||options), 1, 36), 36, ' ')||'|'||
    rpad(substr(object_name||' ',1, 28), 28, ' ')||'|'||
    lpad(decode(cardinality,null,'  ',
    decode(sign(cardinality-1000), -1, cardinality||' ',
    decode(sign(cardinality-1000000), -1, trunc(cardinality/1000)||'K',
    decode(sign(cardinality-1000000000), -1, trunc(cardinality/1000000)||'M',
    trunc(cardinality/1000000000)||'G')))), 7, ' ') || '|' ||
    lpad(decode(bytes,null,' ',
    decode(sign(bytes-1024), -1, bytes||' ',
    decode(sign(bytes-1048576), -1, trunc(bytes/1024)||'K',
    decode(sign(bytes-1073741824), -1, trunc(bytes/1048576)||'M',
    trunc(bytes/1073741824)||'G')))), 6, ' ') || '|' ||
    lpad(decode(cost,null,' ',
    decode(sign(cost-10000000), -1, cost||' ',
    decode(sign(cost-1000000000), -1, trunc(cost/1000000)||'M',
    trunc(cost/1000000000)||'G'))), 8, ' ') || '|' ||
    lpad(decode(object_node,null,' ',
    substr(object_node,length(object_node)-3,1) || ',' ||
    substr(object_node,length(object_node)-1,2))||' ', 6, ' ') || '|' ||
    lpad(decode(other_tag, null,' ',
    decode(other_tag,'PARALLEL_TO_SERIAL', ' P->S',
    decode(other_tag, 'PARALLEL_TO_PARALLEL', ' P->P',
    decode(other_tag, 'PARALLEL_COMBINED_WITH_PARENT', ' PCWP',
    decode(other_tag, 'PARALLEL_FROM_SERIAL', ' S->P',
    decode(other_tag, 'PARALLEL_COMBINED_WITH_CHILD', ' PCWC',
    decode(other_tag,null,' ',other_tag)))))))||' ', 6, ' ') || '|' ||
    rpad(' '||decode(distribution, null,' ',
    decode(distribution, 'PARTITION (ROWID)', 'PART (RID)',
    decode(distribution, 'PARTITION (KEY)', 'PART (KEY)',
    decode(distribution, 'ROUND-ROBIN', 'RND-ROBIN',
    decode(distribution, 'BROADCAST', 'BROADCAST', distribution))))), 12, ' ')
    || '|' ||
    lpad(decode(partition_start, 'ROW LOCATION', 'ROWID',
    decode(partition_start, 'KEY', 'KEY', decode(partition_start,
    'KEY(INLIST)', 'KEY(I)', decode(substr(partition_start, 1, 6),
    'NUMBER', substr(substr(partition_start, 8, 10), 1,
    length(substr(partition_start, 8, 10))-1),
    decode(partition_start,null,' ',partition_start)))))||' ', 7, ' ')
    || '|' ||
    lpad(decode(partition_stop, 'ROW LOCATION', 'ROW L',
    decode(partition_stop, 'KEY', 'KEY', decode(partition_stop,
    'KEY(INLIST)', 'KEY(I)', decode(substr(partition_stop, 1, 6),
    'NUMBER', substr(substr(partition_stop, 8, 10), 1,
    length(substr(partition_stop, 8, 10))-1),
    decode(partition_stop,null,' ',partition_stop)))))||' ', 7, ' ')||'|'
    as "Explain plan"
from
    COE_PLAN_TABLE_XYZ
where
    STATEMENT_ID = 'COE_XPLAIN'
and :CBO_PLAN > 0
start with id=0
and STATEMENT_ID = 'COE_XPLAIN'
and timestamp = (select max(timestamp)
                 from COE_PLAN_TABLE_XYZ
                 where id=0)
connect by prior id = parent_id
        and prior nvl(statement_id, ' ') = nvl(statement_id, ' ')
        and prior timestamp <= timestamp
union all
select '------------------------------'||
    '-----------------------------------------------------------------------'||
    '-------------------------------------'
from dual
where :CBO_PLAN > 0;
SET recsep wr;

/* VII.b Displays Tables by Join Order                                       */
/* ========================================================================= */
BREAK ON EXECUTION_ORDER_T ON TABLE_NAME_J;
SELECT
    TABLE_NAME
    TABLE_NAME_J,      -- Tables by Join Order
    TABLE_ONLY,        -- Table only
    INDEX_ONLY,        -- Index only
    INDEX_METHOD,      -- Table/Index Access Method
    EXECUTION_ORDER_T, -- Table execution order
    EXECUTION_ORDER_I  -- Index execution order
FROM
    COE_JOIN_ORDER_XYZ
ORDER BY
    DECODE(EXECUTION_ORDER_T,0,EXECUTION_ORDER_I,EXECUTION_ORDER_T),
    EXECUTION_ORDER_I;

PROMPT
/* VIII. TABLES Section                                                      */
/* ========================================================================= */
PROMPT
PROMPT I. TABLES
PROMPT =========
SELECT
    CT.TABLE_NUM,          -- Table Number
    AA.OBJECT_ID,          -- Object id
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,       -- Table Owner and Name
    CT.ROWS_COUNT,         -- Count(*) on Table
    to_number(AT.DEGREE)
        DEGREE,            -- Degree of Parallelism
    AT.CHAIN_CNT,          -- Count of rows that are chained
    AT.FREELISTS
FROM
    ALL_OBJECTS      AA,
    ALL_TABLES       AT,
    COE_TABLES_XYZ   CT    -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = AT.OWNER
AND CT.TABLE_NAME  = AT.TABLE_NAME
AND CT.TABLE_OWNER = AA.OWNER
AND CT.TABLE_NAME  = AA.OBJECT_NAME
AND AA.OBJECT_TYPE = 'TABLE'
ORDER BY
    CT.TABLE_NUM;

PROMPT
PROMPT I.a TABLE Statistics
PROMPT ====================
CLEAR breaks;
SELECT
    CT.TABLE_NUM,          -- Table Number
    AT.NUM_ROWS,           -- Number of Rows in Table according to Analyze
    ROUND(ABS(CT.ROWS_COUNT-AT.NUM_ROWS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)*100,1)
        DELTA_PERCENT,     -- Delta % = ABS(A-B)/A
    AT.AVG_ROW_LEN,        -- Average Row Length in bytes
    AT.BLOCKS
       USED_BLOCKS,        -- Used Blocks in Table
    AT.EMPTY_BLOCKS,       -- Empty Blocks in Table
    AT.AVG_SPACE,          -- Avg free space per allocated block in bytes
    ROUND(AT.AVG_SPACE/TO_NUMBER(VP.VALUE)*100,3)
       AVG_SPACE_PERCENT   -- Avg free space per allocated block (percent)
FROM
    V$PARAMETER      VP,
    ALL_TABLES       AT,
    COE_TABLES_XYZ   CT    -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = AT.OWNER
AND CT.TABLE_NAME  = AT.TABLE_NAME
AND VP.NAME        = 'db_block_size'
ORDER BY
    CT.TABLE_NUM;

PROMPT
PROMPT I.b TABLE Storage Parameters
PROMPT ============================
CLEAR breaks;
SELECT
    CT.TABLE_NUM,          -- Table Number
    AT.TABLESPACE_NAME,    -- Tablespace
    AT.PCT_FREE,           -- Minimum percentage of free space per block
    AT.PCT_USED,           -- Minimum percentage of used space per block
    AT.INITIAL_EXTENT,     -- Initial Extent size in bytes
    AT.NEXT_EXTENT,        -- Next Extent size in bytes
    AT.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    AT.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    AT.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    ALL_TABLES        AT,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER  = AT.OWNER
AND CT.TABLE_NAME   = AT.TABLE_NAME
AND CT.PARTITIONED <> 'YES'
ORDER BY
    CT.TABLE_NUM;

PROMPT
PROMPT I.c TABLE Extents
PROMPT =================
BREAK ON TABLE_NUM SKIP 1 -
      ON TABLESPACE_NAME;
COMPUTE SUM LABEL "" OF BLOCKS BYTES ON TABLE_NUM;
SELECT
    CT.TABLE_NUM,          -- Table Number
    DE.TABLESPACE_NAME,    -- Tablespace
    DE.EXTENT_ID,          -- Extent ID
    DE.FILE_ID,            -- File ID
    DE.BLOCK_ID,           -- Block ID from
    DE.BLOCK_ID + DE.BLOCKS - 1
        BLOCK_TO,          -- Block ID to
    DE.BLOCKS,             -- Number of Blocks
    DE.BYTES               -- Number of Bytes
FROM
    DBA_EXTENTS     DE,
    COE_TABLES_XYZ  CT
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y'
AND CT.TABLE_OWNER  = DE.OWNER
AND CT.TABLE_NAME   = DE.SEGMENT_NAME
AND CT.PARTITIONED <> 'YES'
AND DE.SEGMENT_TYPE = 'TABLE'
ORDER BY
    CT.TABLE_NUM,
    DE.TABLESPACE_NAME,
    DE.EXTENT_ID;

/* IX. INDEXES Section                                                       */
/* ========================================================================= */
CLEAR breaks;
CLEAR computes;
PROMPT
PROMPT II. INDEXES
PROMPT ===========
BREAK ON TABLE_NUM SKIP 1;
SELECT
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_OWNER||'.'||CI.INDEX_NAME
        OWNER_INDEX,        -- Index Owner and Name
    AI.UNIQUENESS,          -- UNIQUE or NONUNIQUE
    AI.STATUS,              -- VALID or UNUSABLE
    AI.FREELISTS
FROM
    ALL_OBJECTS       AA,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI   -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.a INDEX Statistics
PROMPT =====================
BREAK ON TABLE_NUM SKIP 1;
SELECT
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    AI.DISTINCT_KEYS        -- Number of Distinct code combinations in Index
FROM
    ALL_OBJECTS       AA,
    ALL_TABLES        AT,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI    -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.TABLE_OWNER  = AT.OWNER
AND CI.TABLE_NAME   = AT.TABLE_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.b INDEX Statistics (2nd part)
PROMPT ================================
BREAK ON TABLE_NUM SKIP 1;
SELECT
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    AI.BLEVEL,              -- B*-Tree level (index depth)
    AI.LEAF_BLOCKS,         -- Number of leaf blocks
    AI.AVG_LEAF_BLOCKS_PER_KEY, -- Avg num of leaf blocks per key
    AI.AVG_DATA_BLOCKS_PER_KEY, -- Avg num of data blocks per key
    AI.CLUSTERING_FACTOR    -- Between Num Blocks and Num Rows
FROM
    ALL_OBJECTS       AA,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
GROUP BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AA.OBJECT_ID,
    CI.INDEX_NAME,
    AI.BLEVEL,
    AI.LEAF_BLOCKS,
    AI.AVG_LEAF_BLOCKS_PER_KEY,
    AI.AVG_DATA_BLOCKS_PER_KEY,
    AI.CLUSTERING_FACTOR
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.c INDEX Storage Parameters
PROMPT =============================
BREAK ON TABLE_NUM SKIP 1;
SELECT
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    AI.TABLESPACE_NAME,    -- Tablespace
    AI.PCT_FREE,           -- Minimum percentage of free space per block
    AI.INITIAL_EXTENT,     -- Initial Extent size in bytes
    AI.NEXT_EXTENT,        -- Next Extent size in bytes
    AI.MIN_EXTENTS,        -- Minimum number of Extents for this Index
    AI.MAX_EXTENTS,        -- Maximum number of Extents for this Index
    AI.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.PARTITIONED <> 'YES'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.d INDEX Extents
PROMPT ==================
BREAK ON TABLE_NUM SKIP 2 -
      ON INDEX_NUM SKIP 1 -
      ON TABLESPACE_NAME;
COMPUTE SUM LABEL "" OF BLOCKS BYTES ON TABLE_NUM INDEX_NUM;
SELECT
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    DE.TABLESPACE_NAME,    -- Tablespace
    DE.EXTENT_ID,          -- Extent ID
    DE.FILE_ID,            -- File ID
    DE.BLOCK_ID,           -- Block ID from
    DE.BLOCK_ID + DE.BLOCKS - 1
        BLOCK_TO,          -- Block ID to
    DE.BLOCKS,             -- Number of Blocks
    DE.BYTES               -- Number of Bytes
FROM
    DBA_EXTENTS     DE,
    COE_INDEXES_XYZ CI
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y'
AND CI.INDEX_OWNER  = DE.OWNER
AND CI.INDEX_NAME   = DE.SEGMENT_NAME
AND CI.PARTITIONED <> 'YES'
AND DE.SEGMENT_TYPE = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    DE.TABLESPACE_NAME,
    DE.EXTENT_ID;

/* X. COLUMNS Section                                                        */
/* ========================================================================= */
PROMPT
PROMPT III. COLUMNS
PROMPT ============
BREAK ON TABLE_NUM ON INDEX_NUM ON OBJECT_ID ON INDEX_NAME SKIP 1;
SELECT
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    AA.OBJECT_ID,          -- Object id
    CI.INDEX_NAME,         -- Index Name
    AIC.COLUMN_POSITION,   -- Position within Index
    ATC.COLUMN_ID,         -- Column id
    AIC.COLUMN_NAME,       -- Column Name (ordered by column_position)
    DECODE(ATC.NULLABLE,'N','NOT NULL')
        NULLABLE,          -- NULL or NOT NULL
    ATC.DATA_TYPE||DECODE(ATC.DATA_TYPE,
        'VARCHAR2','('||ATC.DATA_LENGTH||')',
        'CHAR','('||ATC.DATA_LENGTH||')',
        'NUMBER',DECODE(ATC.DATA_PRECISION,NULL,NULL,'('||ATC.DATA_PRECISION||
           DECODE(ATC.DATA_SCALE,NULL,NULL,0,NULL,','||ATC.DATA_SCALE)||')'))
        DATA_TYPE          -- Data Type and length
FROM
    ALL_OBJECTS       AA,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
   CI.TABLE_NUM,
   CI.INDEX_NUM,
   AIC.COLUMN_POSITION;

PROMPT
PROMPT III.a INDEX COLUMN Statistics
PROMPT =============================
BREAK ON TABLE_NUM ON INDEX_NUM ON INDEX_NAME SKIP 1;
SELECT
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_NAME,         -- Index Name
    AIC.COLUMN_NAME,       -- Column Name (ordered by column_position)
    ATC.NUM_NULLS,         -- Number of Rows with NULLs in this column
    AT.NUM_ROWS - NVL(ATC.NUM_NULLS,0)
        NOT_NULLS,         -- Number of Rows with Value
    ATC.NUM_DISTINCT,      -- Number of Distinct values on this column
    CEIL((AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT))
        COLUMN_CARDINALITY,-- The Lower the better.  1 is the best.
    (AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
        COLUMN_SELECTIVITY,-- Column Selectivity
    ATC.DENSITY            -- Column Density (possible due to Histograms)
FROM
    ALL_TABLES        AT,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.TABLE_OWNER  = AT.OWNER
AND CI.TABLE_NAME   = AT.TABLE_NAME
ORDER BY
   CI.TABLE_NUM,
   CI.INDEX_NUM,
   CI.INDEX_NAME,
   AIC.COLUMN_POSITION;

PROMPT
PROMPT III.b TABLE COLUMN Statistics
PROMPT =============================
CLEAR breaks;
SELECT
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME          -- Table Name
FROM
    COE_TABLES_XYZ CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y';

BREAK ON TABLE_NUM SKIP 1;
SELECT
    CT.TABLE_NUM,          -- Table Number
    ATC.COLUMN_ID,         -- Sequence number of column as created
    ATC.COLUMN_NAME,       -- Column Name
    DECODE(ATC.NULLABLE,'N','NOT NULL')
        NULLABLE,          -- NULL or NOT NULL
    ATC.DATA_TYPE||DECODE(ATC.DATA_TYPE,
        'VARCHAR2','('||ATC.DATA_LENGTH||')',
        'CHAR','('||ATC.DATA_LENGTH||')',
        'NUMBER',DECODE(ATC.DATA_PRECISION,NULL,NULL,'('||ATC.DATA_PRECISION||
           DECODE(ATC.DATA_SCALE,NULL,NULL,0,NULL,','||ATC.DATA_SCALE)||')'))
        DATA_TYPE,         -- Data Type and length
    to_char(ATC.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,     -- Last Analyzed
    ATC.SAMPLE_SIZE,       -- Sample Size used when Analyzed
    ATC.NUM_BUCKETS        -- Num. of Buckets for Histograms
FROM
    ALL_TAB_COLUMNS   ATC,
    COE_TABLES_XYZ    CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y'
AND CT.TABLE_OWNER  = ATC.OWNER
AND CT.TABLE_NAME   = ATC.TABLE_NAME
ORDER BY
    CT.TABLE_NUM,
    ATC.COLUMN_ID;

PROMPT
PROMPT III.c TABLE COLUMN Statistics (2nd part)
PROMPT ========================================
CLEAR breaks;
SELECT
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME          -- Table Name
FROM
    COE_TABLES_XYZ CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y';

BREAK ON TABLE_NUM SKIP 1;
SELECT
    CT.TABLE_NUM,            -- Table Number
    ATC.COLUMN_ID,           -- Sequence number of column as created
    ATC.COLUMN_NAME,         -- Column Name
    ATC.NUM_NULLS,           -- Number of Rows with NULLs in this column
    AT.NUM_ROWS - NVL(ATC.NUM_NULLS,0)
        NOT_NULLS,           -- Number of Rows with Value
    ATC.NUM_DISTINCT,        -- Number of Distinct values on this column
    CEIL((AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT))
        COLUMN_CARDINALITY,  -- The Lower the better.  1 is the best.
    (AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
        COLUMN_SELECTIVITY_2,-- Column Selectivity
    ATC.DENSITY
        DENSITY_2,           -- Column Density (possible due to Histograms)
    (ATC.DENSITY-(AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS))
        DENSITY_MISMATCH     -- Internal Bug
FROM
    ALL_TAB_COLUMNS   ATC,
    ALL_TABLES        AT,
    COE_TABLES_XYZ    CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y'
AND CT.TABLE_OWNER  = AT.OWNER
AND CT.TABLE_NAME   = AT.TABLE_NAME
AND CT.TABLE_OWNER  = ATC.OWNER
AND CT.TABLE_NAME   = ATC.TABLE_NAME
ORDER BY
    CT.TABLE_NUM,
    ATC.COLUMN_ID;

/* XI. v$parameter and product component version Section                     */
/* ========================================================================= */
PROMPT
PROMPT V. INIT.ORA parameters
PROMPT ======================
SELECT VP.NAME  pname,
       VP.VALUE pvalue
  FROM V$PARAMETER VP
 WHERE VP.ISDEFAULT = 'FALSE'
 ORDER BY
       VP.NAME;

PROMPT
PROMPT VI. Product Component Versions
PROMPT ==============================
SELECT
    PRODUCT,
    VERSION,
    STATUS
FROM
    PRODUCT_COMPONENT_VERSION;

/* XII. Finishing Section                                                    */
/* ========================================================================= */
PROMPT
PROMPT coe_statement_&&1 and coe_xplain_&&1 files are complete.
PROMPT
PROMPT Recover the following files, compress them into a single file
PROMPT coexplain.zip and send/upload the resulting coexplain.zip file for
PROMPT further analysis:
PROMPT 1. coe_statement_&&1
PROMPT 2. coe_xplain_&&1
PROMPT
PROMPT If you wish to print output files nicely, open them in Wordpad or Word.
PROMPT Use File -> Page Setup (menu option) to change Orientation to Landscape.
PROMPT Using same menu option make all 4 Margins 0.2".  Exit this menu option.
PROMPT Do a 'Select All' (Ctrl+A) and change Font to 'Courier New' Size 8.
SPOOL OFF;
/* If you wish to drop staging tables, remove comments from this section     */
-- DROP TABLE COE_PLAN_TABLE_XYZ;
-- DROP TABLE COE_JOIN_ORDER_XYZ;
-- DROP TABLE COE_TABLES_XYZ;
-- DROP TABLE COE_INDEXES_XYZ;
/* Last table stores Stats for objects accessed, you may need to export it   */
SET ver on trims off pages 24 lin 80 feed on numf 9999999999 long 80;
SET sqlp SQL> sqln on recsep wr;
UNDEFINE 1,include_count,include_extents,include_all_columns;
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS') ENDED FROM SYS.DUAL;