/*$Header: coe_xplain.sql 8.1-9.0 156958.1 2002/09/03           csierra coe $*/
SET term off;
/*=============================================================================

coe_xplain.sql - Enhanced Explain Plan for given SQL Statement (8.1-9.0)

    *************************************************************
    This article is being delivered in Draft form and may contain
    errors.  Please use the MetaLink "Feedback" button to advise
    Oracle of any issues related to this article.
    *************************************************************


 Overview
 --------

    coe_xplain.sql generates an Enhanced Explain Plan for one SQL statement
    to diagnose apps performance issues (sql tuning).

    Includes relevant statistics for tables, indexes and columns.

    Displays histograms, storage parameters and database parameters.

    It also exports object statistics and produces a CBO trace.


 Instructions
 ------------

 1. Copy this whole Note into a text file.  Name it coe_xplain.sql when
    saving your text file.  Be sure filename is coe_xplain.sql.

 2. Create a flat file with one SQL statement for which you want to generate
    its explain plan.  Name this text file sql.txt.  It should have one and
    only one SQL statement.  Your SQL statement should NOT have a semicolon at
    the end.  It should end with either a space, or a single blank line.
    The space at the end is because in some environments, the last character
    of the SQL statement in sql.txt gets truncated, so if you add a space ' '
    or a single blank line at the end, your SQL statement will be still
    complete.  Do not include more than one single blank line at the end, or
    you may get a message like 'Bind variable "B2" not declared'.

 3. There is no need to remove any bind variable from your SQL statement.  Do
    not replace bind variables with literals either.

 4. Save your sql.txt file.  Name of text file is not hardcoded, therefore you
    can use sql1.txt, sql2.txt and so on.

 5. Download coe_view.sql from Note: 156972.1.  Read instructions on Note.

 6. Place coe_xplain.sql, sql.txt and coe_view.sql flat files into same
    dedicated directory.
    coe_xplain.sql will try to open sql.txt and coe_view.sql under same
    directory.

 7. Execute coe_xplain.sql from SQL*Plus connected as user with access to all
    objects referenced by SQL statement in sql.txt.  User should also have
    access to "ALL_", "DBA_" and "V$" views.
    If you are using coe_xplain.sql within an Apps instance, connect as APPS,
    otherwise connect as corresponding user with access to all objects
    referenced by SQL statement, plus "ALL_", "DBA_" and "V$" views:
    # sqlplus apps/apps@vis11i
    SQL> START coe_xplain.sql sql.txt;

 8. Review output files (spool): COE_XPLAIN_SQL.TXT and COE_STATEMENT_SQL.TXT
    The spool files get created on same directory from which coe_xplain.sql is
    executed.  SQL.TXT suffix represents filename provided in parameter 1.
    On NT, files may get created under $ORACLE_HOME/bin.

 9. Provide to Support spool files compressed into a *.zip file according to
    instructions at the end of the generated COE_XPLAIN_SQL.TXT file.

10. If requested, provide also raw SQL Trace generated by the script and/or
    COE_STATTAB_XYZ.dmp file created as an export of COE_STATTAB_XYZ table.


 Program Notes
 -------------

 1. Always download latest version from Metalink (Note:156958.1), or ftp from

    ftp://oracle-ftp.oracle.com/apps/patchsets/AOL/SCRIPTS/PERFORMANCE/

    In order to avoid cut and paste or word wraping issues, use better ftp

 2. The Explain Plan is spooled to file COE_XPLAIN_SQL.TXT.
    The original SQL statement is spooled to COE_STATEMENT_SQL.TXT
    SQL.TXT suffix represents filename provided in parameter 1.

 3. If you need to ftp spool files from UNIX to any other system, use ASCII.

 4. Open the spooled files using WordPad, change the font to Courier New, style
    regular and size 8.  Set up the page to Lanscape with all 4 margins 0.2 in.

 5. This script has been tested up to Oracle Apps 11.5.4 with Oracle 8.1.7.

 6. Table COE_HISTOGRAMS has been created to workaround an internal Bug fixed
    on release 9.0.1 (poor performance on TAB_HISTOGRAMS views)

 7. If any of the objects in the SQL statement is partitioned, this script
    will take several minutes to execute.  This is because the data dictionary
    views for partitioned objects are not well tuned for joins.

 8. Selectivity mismatch was reported on internal Bug fixed on 9.0.0.

 9. Personalize replacing all XYZ with initials to avoid collisions under a
    concurrent environment (i.e. during training), otherwise don't replace.

10. To import the exported statistics into a Test instance follow these steps
    10.1 Drop or tuncate table COE_STATTAB_XYZ in your Test instance
    10.2 O/S command as Oracle: imp apps/apps file=COE_STATTAB_XYZ full=y
    10.3 From SQL*Plus under APPS run coe_import_stattab.sql to populate stats

11. If you want to verify index fragmentation of all indexes which belong to
    tables acccesed according to explain plan, use optional script
    bde_analyze_indexes.sql (Note:182049.1).  Execute bde_analyze_indexes.sql
    after coe_xplain.sql.

12. Dynamically generated coe_fix_stats.sql scripts must be executed only if
    requested by Support.  It refreshes your stats for objects in plan.

13. Dynamically generated coe_rebuild_indexes.sql and coe_recreate_indexes.sql
    scripts must be executed only if requested by Oracle Support.
    coe_rebuild_indexes.sql sets initrans=2, pctfree=0% and compress = 'yes'
    aimed to improve performance and space utilization of leaf blocks.
    It may be used to de-fragmentate indexes.
    coe_recreate_indexes.sql is capable of droping and recreating all indexes
    for related tables (non-partitioned and b*tree) conserving same storage
    parameters.  Again, don't execute unless instructed by Oracle Support.
    These two scripts are usually edited before execution.

14. For Oracle 8.1 or 9.0 use coe_xplain.sql from Note:156958.1
    For Oracle 8.0 use coe_xplain_80.sql from Note:156959.1
    For Oracle 7.3 use coe_xplain_73.sql from Note:156960.1

15. Download coe_import_stattab.sql from Note:156964.1 if needed.

16. If sending COE_STATTAB_XYZ.dmp, it is imperative to compress this file on
    same server in which it is created (usually a UNIX box), then transfer
    between computers and/or upload as a BINARY file, otherwise it get
    corrupted and useless.  COE_STATTAB_XYZ.dmp is BINARY.

17. At the end of the execution of this coe_xplain.sql script, it executes
    dynamically generated coe_start_view.sql script to create a set of files
    with view definitions for all non-mergeable views on explain plan.

18. If you get no info in the coe_xplain_sql.txt report and a message on the
    coe_statement_sql.txt similar to 'Bind variable "B2" not declared', review
    your sql.txt file since it may have more than one blank line at the end.

19. For other SQL Tuning scripts, search on Metalink using keyword coescripts.

20. A practical guide in Troubleshooting Oracle ERP Applications Performance
    Issues can be found on Metalink under Note:169935.1


 Parameters
 ----------

    coe_xplain.sql requires one user parameter to specify the name of the file
    containing the SQL statement to be explained.  This parameter is passed
    on the same command line used to execute coe_xplain.sql.

    # sqlplus apps/apps@vis11i
    SQL> START coe_xplain.sql sql.txt;

    coe_xplain.sql includes also 3 fixed or seeded parameters.  They should
    only be changed if requested by Support.  They have been seeded with
    default values below.

 1. Include count(*) of Tables? [Y]

        Y - Creates and runs a SQL script to perform a count(*) on all Tables
            referenced in the Explain Plan.  It may be slow but it is highly
            recommended, specially for RULE based optimizer (DEFAULT)

        N - Does not display count(*) information for all Tables

 2. Include Segment Extents? [N]

        N - Skips the display of Segment Extents (DEFAULT)

        Y - Displays counts and summarizes of Segment Extents for each Object
            referenced in Explain Plan.  This step may be very slow.
            Request this detailed option only when really needed.

 3. Include all Table Columns? [Y]

        Y - Extracts and displays all Columns for all Tables referenced in
            Explain Plan (DEFAULT)

        N - Displays statistics only for those Columns included in at least
            one Index of a Table referenced in the Explain Plan



 Caution
 -------

    The sample program in this article is provided for educational purposes
    only and is NOT supported by Oracle Support Services.  It has been tested
    internally, however, and works as documented.  We do not guarantee that it
    will work for you, so be sure to test it in your environment before
    relying on it.


 Portal
 ------

    Abstract: coe_xplain.sql - Enhanced Explain Plan for given SQL Statement
    Author: Carlos Sierra
    Date: 03-SEP-02
    Description: Non-intrusive SQL Tuning tool to diagnose performance issues
    EMail: carlos.sierra@oracle.com
    Internal_Only: N
    Keywords: explainplan sqltuning coescripts appsperf appssqltuning coe bde
    Metalink_Note: 156958.1
    New_Win: Y
    Product: SQL*Plus script
    Version: 8.1-9.0 2002/09/03
    Download: coe_xplain.zip

   ========================================================================= */

SET lin 500 term on ver off trims on serveroutput on size 1000000 feed off;
PROMPT
PROMPT ========================================================================
PROMPT coe_xplain.sql - Enhanced Explain Plan for given SQL statement (8.1-9.0)
PROMPT ========================================================================
PROMPT
PROMPT Parameter 1 specifies filename of flat file containing SQL statement
PROMPT
SET term off;

/* if you want to enable user parameters, remove two comment lines (this line
   and this one).  Remove line after 3rd accept, and remove 3 define commands.
SET term on;
PROMPT Unless otherwise instructed by Support, hit <Enter> at each parameter.
PROMPT All parameters will default to value in brackets.  Valid values: Y or N.
PROMPT
accept include_count       prompt '1. Include count(*) of Tables? [Y] ';
accept include_extents     prompt '2. Include Segment Extents?    [N] ';
accept include_all_columns prompt '3. Include all Table Columns?  [Y] ';
*/

define include_count       = Y;
define include_extents     = N;
define include_all_columns = Y;

/* II. DDL Section - Create COE Temporary Tables
   ========================================================================= */
SET lin 500 term on ver off trims on serveroutput on size 1000000 feed off;
PROMPT Creating COE staging tables...
PROMPT
SET term off;
DROP   TABLE COE_PLAN_TABLE_XYZ;
CREATE TABLE COE_PLAN_TABLE_XYZ
    (statement_id varchar2(30),timestamp date,remarks varchar2(80),
     operation varchar2(30),options varchar2(30),object_node varchar2(128),
     object_owner varchar2(30),object_name varchar2(30),
     object_instance numeric,object_type varchar2(30),
     optimizer varchar2(255),search_columns number,id numeric,
     parent_id numeric,position numeric,cost numeric,cardinality numeric,
     bytes numeric,other_tag varchar2(255),partition_start varchar2(255),
     partition_stop varchar2(255),partition_id numeric,other long,
     distribution varchar2(30),cpu_cost numeric,io_cost numeric,
     temp_space numeric,execution_order numeric,icolumns varchar2(600),
     version number) NOLOGGING CACHE;
DROP   TABLE COE_JOIN_ORDER_XYZ;
CREATE TABLE COE_JOIN_ORDER_XYZ
    (EXECUTION_ORDER_T NUMERIC,EXECUTION_ORDER_I NUMERIC,
     TABLE_NAME VARCHAR2(30),TABLE_ONLY VARCHAR2(3),INDEX_ONLY VARCHAR2(3),
     INDEX_METHOD VARCHAR2(50)) NOLOGGING CACHE;
DROP   TABLE COE_TABLES_XYZ;
CREATE TABLE COE_TABLES_XYZ
    (TABLE_OWNER VARCHAR2(30),TABLE_NAME VARCHAR2(30),TABLE_NUM NUMBER,
     ROWS_COUNT NUMBER,PARTITIONED VARCHAR2(3),PERCENT NUMBER,
     NUM_IO_FTS NUMBER, TABLESPACE_NAME VARCHAR2(30)) NOLOGGING CACHE;
DROP   TABLE COE_INDEXES_XYZ;
CREATE TABLE COE_INDEXES_XYZ
    (TABLE_OWNER VARCHAR2(30),TABLE_NAME VARCHAR2(30),TABLE_NUM NUMBER,
     INDEX_OWNER VARCHAR2(30),INDEX_NAME VARCHAR2(30),INDEX_NUM NUMBER,
     PARTITIONED VARCHAR2(3),ICOMPRESS VARCHAR2(3),NUM_IO_FIRS NUMBER,
     BEP_FTS_FIRS NUMBER,IN_PLAN VARCHAR2(3),ICOLUMNS VARCHAR2(600),
     TABLESPACE_NAME VARCHAR2(30)) NOLOGGING CACHE;
DROP   TABLE COE_SEGMENTS_XYZ;
CREATE TABLE COE_SEGMENTS_XYZ
    (OWNER VARCHAR2(30),SEGMENT_NAME VARCHAR2(30), PARTITION_NAME VARCHAR2(30),
     SEGMENT_TYPE VARCHAR2(17),TABLESPACE_NAME VARCHAR2(30),BYTES NUMBER,
     BLOCKS NUMBER,EXTENTS NUMBER,INITIAL_EXTENT NUMBER,NEXT_EXTENT NUMBER,
     MIN_EXTENTS NUMBER,MAX_EXTENTS NUMBER,PCT_INCREASE NUMBER,
     FREELISTS NUMBER,FREELIST_GROUPS NUMBER) NOLOGGING CACHE;
DROP   TABLE COE_EXTENTS_XYZ;
CREATE TABLE COE_EXTENTS_XYZ
    (OWNER VARCHAR2(30),SEGMENT_NAME VARCHAR2(30),PARTITION_NAME VARCHAR2(30),
     SEGMENT_TYPE VARCHAR2(17),EXTENT_ID NUMBER,FILE_ID NUMBER,
     BLOCK_ID NUMBER,BYTES NUMBER,BLOCKS NUMBER) NOLOGGING CACHE;
DROP   TABLE COE_HISTOGRAMS_XYZ;
CREATE TABLE COE_HISTOGRAMS_XYZ
    (TABLE_NUM NUMBER,TABLE_OWNER VARCHAR2(30),TABLE_NAME VARCHAR2(30),
     COLUMN_NAME VARCHAR2(30),ENDPOINT_NUMBER NUMBER,ENDPOINT_VALUE NUMBER,
     ENDPOINT_ACTUAL_VALUE VARCHAR2(30), ENDPOINT_JULIAN NUMBER(7))
    NOLOGGING CACHE;
DROP   TABLE COE_HISTOGRAM_COLS_XYZ;
CREATE TABLE COE_HISTOGRAM_COLS_XYZ
    (TABLE_NUM NUMBER,TABLE_NAME VARCHAR2(30),COLUMN_NAME VARCHAR2(30),
     PARTITION VARCHAR2(30),HSIZE NUMBER) NOLOGGING CACHE;
DROP   TABLE COE_POLICIES_XYZ;
CREATE TABLE COE_POLICIES_XYZ
    (OBJECT_OWNER VARCHAR2(30),OBJECT_NAME VARCHAR2(30),
     POLICY_NAME VARCHAR2(30),PF_OWNER VARCHAR2(30),PACKAGE VARCHAR2(30),
     FUNCTION VARCHAR2(30),SEL VARCHAR2(3),INS VARCHAR2(3),UPD VARCHAR2(3),
     DEL VARCHAR2(3),CHK_OPTION VARCHAR2(3),ENABLE VARCHAR2(3),
     PB_HEADER VARCHAR2(80))
    NOLOGGING CACHE;
DROP   TABLE COE_PARAMETERS_XYZ;
CREATE TABLE COE_PARAMETERS_XYZ
    (NAME VARCHAR2(64),VALUE VARCHAR2(512),REQUIRED VARCHAR2(512),
     RECOMMENDED VARCHAR2(512),DEFAULTED VARCHAR2(512)) NOLOGGING CACHE;
DROP   TABLE COE_STATTAB_XYZ;
DECLARE
    my_stats_owner VARCHAR2(30);
    my_stats_table VARCHAR2(30);
BEGIN
    SELECT user into my_stats_owner from sys.dual ;
    my_stats_table  := 'COE_STATTAB_XYZ' ;
    DBMS_STATS.CREATE_STAT_TABLE(my_stats_owner, my_stats_table);
END;
/

/* III. Generate Explain Plan Section
   ========================================================================= */
alter session set events '10053 trace name context forever, level 1';
SET pages 1000 sqlp '' sqln off autotrace off term on;
SPOOL coe_statement_&&1;
PROMPT ========================================================================
PROMPT Generating Enhanced Explain Plan for SQL statement on file &&1
PROMPT ========================================================================
get &&1
0 explain plan set statement_id = 'COE_XPLAIN' into COE_PLAN_TABLE_XYZ for
/
/* ========================================================================= */
SET echo off;
SPOOL OFF;
PROMPT Computing Execution Order...
SET term off;
alter session set events '10053 trace name context off';

/* IV. Compute Execution Order Section
   ========================================================================= */
DECLARE
    coe_pointer     number := 0;  -- Row on COE_PLAN_TABLE being processed.
    coe_next_order  number := 1;  -- To update Execution Order
    coe_xplain      CONSTANT varchar2(30) := 'COE_XPLAIN'; -- statement_id.
    coe_parent_id   number;       -- To move pointer (only if needed).
    coe_curr_order  varchar2(80); -- Order in current row of COE_PLAN_TABLE.
    coe_count_child number;       -- Number of children for a parent.
BEGIN
    LOOP
        SELECT parent_id, execution_order    -- Reads COE_PLAN_TABLE w/pointer.
        INTO   coe_parent_id, coe_curr_order -- Starts on first row (id=0) and
        FROM   COE_PLAN_TABLE_XYZ            -- works its way down.
        WHERE  id           = coe_pointer
        AND    statement_id = coe_xplain;
        IF  coe_curr_order is not null THEN  -- When row has already its Order:
            EXIT WHEN coe_pointer = 0;       -- Exit Loop if back at the Top.
            coe_pointer := coe_parent_id;    -- Else, move pointer to parent.
        ELSE                                 -- When doesn't have Order yet:
            SELECT count(*)                  -- Determines if there is any
            INTO   coe_count_child           -- child for the current parent
            FROM   COE_PLAN_TABLE_XYZ        -- pending to receive Order.
            WHERE  parent_id        = coe_pointer
            AND    execution_order is null
            AND    statement_id     = coe_xplain;
            IF  coe_count_child     = 0 THEN -- If no child is pending:
                UPDATE COE_PLAN_TABLE_XYZ    -- row gets new Order.
                SET execution_order = to_char(coe_next_order)
                WHERE  id           = coe_pointer
                AND    statement_id = coe_xplain;
                coe_next_order := coe_next_order + 1; -- Order gets increm.
            ELSE                             -- If at least one pending child:
                SELECT id                    -- Move pointer to first pending
                INTO   coe_pointer           -- child.
                FROM   COE_PLAN_TABLE_XYZ
                WHERE  parent_id        = coe_pointer
                AND    execution_order is null
                AND    rownum           = 1
                AND    statement_id     = coe_xplain;
            END IF;
        END IF;
    END LOOP;
END;
/

/* V. COLUMN Definition Section
   ========================================================================= */
SET numf 999,999,999;
CLEAR columns;
CLEAR breaks;

VARIABLE cbo_plan number;
VARIABLE db_block_size number;
VARIABLE db_file_multiblock_read_count number;
VARIABLE plan_version number;
VARIABLE dbname varchar2(9);
VARIABLE numcpus number;
VARIABLE iname varchar2(16);
VARIABLE hname varchar2(64);
VARIABLE dbversion varchar2(17);
VARIABLE istartup varchar2(20);
VARIABLE multi_org varchar2(3);
VARIABLE trace_file_name varchar2(120);

COLUMN typ FORMAT a3 HEADING 'Ope|Typ';
COLUMN execution_order FORMAT 9999 HEADING 'Exec|Order';
COLUMN execution_order_t FORMAT b9999 HEADING 'Exec|Order|Table';
COLUMN execution_order_i FORMAT b9999 HEADING 'Exec|Order|Index';
COLUMN table_only FORMAT a5 HEADING 'Table|Only';
COLUMN index_only FORMAT a5 HEADING 'Index|Only';
COLUMN index_method FORMAT a50 HEADING 'Table/Index Access Method';
COLUMN table_name_j FORMAT a30 HEADING 'Tables by Join Order';
COLUMN query_plan FORMAT a140 HEADING -
       'Explain Plan by coe_xplain.sql 8.1/9.0 2002/09/03 Note:156958.1' wor;
COLUMN owner_table FORMAT a37 HEADING 'Owner.Table';
COLUMN owner_index FORMAT a40 HEADING 'Owner.Index';
COLUMN icolumns FORMAT a90 HEADING 'Indexed Columns' wor;
COLUMN owner_trigger FORMAT a45 HEADING 'Owner.Trigger';
COLUMN table_name FORMAT a30 HEADING 'Table';
COLUMN index_name FORMAT a33 HEADING 'Index';
COLUMN last_analyzed FORMAT a15 HEADING 'Last|Analyzed';
COLUMN num_rows FORMAT b999,999,999.999 HEADING -
                    '(B)|Num of rows|in Table|(Cardinality)';
COLUMN num_rows_p FORMAT b9,999,999,999.999 HEADING -
                    '(J)|Num of rows|in Partition|(Cardinality)';
COLUMN num_rows_i FORMAT b9,999,999,999.999 HEADING -
                    '(C)|Number|of rows|in Index';
COLUMN num_rows_ip FORMAT b9,999,999,999.999 HEADING -
                    '(C)|Number|of rows|in Partition';
COLUMN delta_percent FORMAT b999,999.9 HEADING 'Delta|Percent|ABS(A-B)/A';
COLUMN avg_row_len FORMAT 999,999 HEADING 'Avg Row|Length|(bytes)';
COLUMN avg_col_len FORMAT b99,999 HEADING 'Avg Col|Length|(bytes)';
COLUMN num_buckets FORMAT b99,999 HEADING 'Number|Buckets|Histogr';
COLUMN empty_blocks FORMAT b99,999,999 HEADING 'Empty(*)|Blocks|(above HWM)';
COLUMN used_blocks FORMAT b99,999,999 HEADING 'Used|Blocks|(below HWM)';
COLUMN t_blocks FORMAT b99,999,999 HEADING -
       'Est. blocks|if rebuilt|with current|pct_free and|ini_trans';
COLUMN i_blocks FORMAT b99,999,999 HEADING -
   '(N)|Estimated|leaf blocks|if rebuilt|with current|pct_free and|ini_trans';
COLUMN t_blocks2 FORMAT b99,999,999 HEADING -
       'Est. blocks|if rebuilt|with new|pct_free=10%|ini_trans=1';
COLUMN i_blocks2 FORMAT b99,999,999 HEADING -
   '(O)|Estimated|leaf blocks|if rebuilt|with new|pct_free=0%|ini_trans=2';
COLUMN i_waste FORMAT b99,999 HEADING -
'LB (*)|reduction %|if rebuilt|with current|pct_free and|ini_trans|(M-N)/M';
COLUMN i_waste2 FORMAT b99,999 HEADING -
'LB (*)|reduction %|if rebuilt|with new|pct_free=0%|ini_trans=2|(M-O)/M';
COLUMN freelists FORMAT b99 HEADING 'Free|Lists';
COLUMN freelist_groups FORMAT b99 HEADING 'Free|List|Grps';
COLUMN ini_trans FORMAT b9999 HEADING 'Init|Trans';
COLUMN global_stats FORMAT a6 HEADING 'Global|Stats';
COLUMN distinct_keys FORMAT b999,999,999 HEADING '(D)|Distinct|Keys';
COLUMN num_distinct FORMAT b999,999,999 HEADING '(H)|Num of|Distinct|Values';
COLUMN rows_count FORMAT b9,999,999,999 HEADING '(A)|Rows from|Count(*)';
COLUMN index_cardinality FORMAT 999,999,999 HEADING -
                    '(E)|Computed|Index|Cardinality|CEIL(C/D)';
COLUMN index_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Index|Selectivity|((C/D)/B)';
COLUMN index_sel_percent FORMAT 999999999.9 HEADING -
                    'Computed|Index|Selectivity|Percent';
COLUMN part_cardinality FORMAT 999,999,999 HEADING -
                    '(E)|Computed|Partition|Cardinality|CEIL(C/D)';
COLUMN part_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Partition|Selectivity|((C/D)/B)';
COLUMN column_cardinality FORMAT 999,999,999 HEADING -
                    '(I)|Computed|Column|Cardinality|CEIL(G/H)';
COLUMN column_selectivity FORMAT b9.9999eeee HEADING -
                    'Computed|Column|Selectivity|((G/H)/B)';
COLUMN density FORMAT b9.9999eeee HEADING -
                    'Column|Density|from Data|Dictionary';
COLUMN column_selectivity_2 FORMAT b9.9999eeee HEADING -
                    '(K)|Computed|Column|Selectivity|((G/H)/B)';
COLUMN density_2 FORMAT b9.9999eeee HEADING -
                    '(L)|Column|Density|from Data|Dictionary';
COLUMN density_mismatch FORMAT b9.999999 HEADING -
                    'Selectivity|Mismatch|(L-K)';
COLUMN table_num FORMAT 99 HEADING 'Tab|Num';
COLUMN index_num FORMAT 999 HEADING 'Indx|Num';
COLUMN uniqueness FORMAT a10 HEADING 'Uniqueness';
COLUMN column_name FORMAT a30 HEADING 'Column';
COLUMN column_position FORMAT 999 HEADING 'Pos';
COLUMN nullable FORMAT a9 HEADING 'Null?';
COLUMN num_nulls FORMAT 999,999,999 HEADING -
                    '(F)|Number of|Rows with|NULLs in|this column';
COLUMN not_nulls FORMAT 999,999,999 HEADING -
                    '(G)|Number of|Rows with|Value|(B-F)';
COLUMN not_nulls_p FORMAT 999,999,999 HEADING -
                    '(G)|Number of|Rows with|Value|(J-F)';
COLUMN avg_space FORMAT b9,999,999,999 HEADING -
                    'Average(*)|free space|per allocated|block (bytes)';
COLUMN avg_space_percent FORMAT b99,999,999.9 HEADING -
                    'Average(*)|free space|per allocated|block (%)';
COLUMN degree FORMAT a8 HEADING 'Degree|of Para-|llelism';
COLUMN instances FORMAT a10 HEADING 'Instances';
COLUMN partitioned FORMAT a7 HEADING 'Parti-|tioned?';
COLUMN sample_size FORMAT b999,999,999 HEADING 'Sample|Size|(% or|rows)';
COLUMN chain_cnt FORMAT 99,999,999 HEADING 'Chain|Count|(rows)';
COLUMN tablespace_name FORMAT a25 HEADING 'Tablespace';
COLUMN pct_free FORMAT b999 HEADING -
                    'Minimum|percent of|free space|per block|(pct_free)';
COLUMN pct_used FORMAT b999 HEADING -
                    'Minimum|percent of|used space|per block|(pct_used)';
COLUMN initial_extent FORMAT b999,999,999,999 HEADING -
                    'Initial|Extent|size|(bytes)';
COLUMN next_extent FORMAT b999,999,999,999 HEADING -
                    'Next|Extent|size|(bytes)';
COLUMN extents FORMAT 9,999,999 HEADING 'Extents';
COLUMN min_extents FORMAT b999,999 HEADING 'Minimum|num. of|Extents';
COLUMN max_extents FORMAT b9,999,999,999 HEADING 'Maximum num.|of Extents';
COLUMN pct_increase FORMAT b99,999 HEADING -
                    'Percent|increase|size for|Next|Extent';
COLUMN count_extents FORMAT b99,999 HEADING 'Actual|Extents|Count';
COLUMN index_type FORMAT a14 HEADING 'Index Type';
COLUMN status FORMAT a10 HEADING 'Status';
COLUMN blevel FORMAT 999,999 HEADING 'B*-Tree|level|(index|depth)';
COLUMN leaf_blocks FORMAT 9,999,999 HEADING '(M)|Number|of|leaf|blocks';
COLUMN avg_leaf_blocks_per_key FORMAT 9,999,999 HEADING -
                    'Avg num of|leaf blocks|per key';
COLUMN avg_data_blocks_per_key FORMAT 9,999,999 HEADING -
                    'Avg Num of|data blocks|per key';
COLUMN clustering_factor FORMAT 999,999,999 HEADING 'Clustering|factor';
COLUMN data_type FORMAT a14 HEADING 'Type';
COLUMN column_id FORMAT 9999 HEADING 'Col';
COLUMN extent_id FORMAT 999999999 HEADING 'Extent ID';
COLUMN file_id FORMAT 9999999 HEADING 'File ID';
COLUMN block_id FORMAT 9999999999 HEADING 'Starting|Block ID';
COLUMN blocks FORMAT 99,999,999 HEADING 'Blocks';
COLUMN maxblocks FORMAT 99,999,999 HEADING 'Maximum|File|Size|(Blocks)';
COLUMN bytes FORMAT 999,999,999,999 HEADING 'Bytes';
COLUMN megabytes FORMAT 999,999,999.999 HEADING 'Megabytes';
COLUMN autoextensible FORMAT a10 HEADING 'Auto|extensible';
COLUMN increment_by FORMAT 99,999,999 HEADING 'Autoextent|Increment|(Blocks)';
COLUMN file_name FORMAT a70 HEADING 'Filename';
COLUMN pname FORMAT a33 HEADING 'Parameter Name';
COLUMN pvalue1 FORMAT a20 HEADING 'Current|Value';
COLUMN pvalue2 FORMAT a115 HEADING 'Parameter Value';
COLUMN prequired FORMAT a20 HEADING 'Required|Value';
COLUMN precommended FORMAT a20 HEADING 'Recommended|Value';
COLUMN pdefaulted FORMAT a20 HEADING 'Default|Value';
COLUMN object_id FORMAT 99999999 HEADING 'Object';
COLUMN indexed_column FORMAT a7 HEADING 'Indexed|Column';
COLUMN endpoint_number FORMAT 999999999 HEADING 'Bucket|Number';
COLUMN endpoint_value FORMAT B999999999999 HEADING -
                    'Normalized|end point|numeric|value';
COLUMN endpoint_value_e FORMAT b9.999999eeee HEADING -
                    'Normalized|end point|numeric|value (e10)';
COLUMN endpoint_value_d FORMAT a12 HEADING -
                    'Normalized|end point|numeric|value (date)';
COLUMN endpoint_actual_value FORMAT a30 HEADING -
                    'Normalized|end point|actual|value';
COLUMN partition FORMAT a30 HEADING -
                    'Partition according to|FND_HISTOGRAM_COLS';
COLUMN hsize FORMAT 9999999 HEADING 'Num. of|Buckets|(max)';
COLUMN partition_position FORMAT 9999 HEADING 'Part|Pos';
COLUMN partition_name FORMAT a30 HEADING 'Partition Name';
COLUMN composite FORMAT a9 HEADING 'Composite';
COLUMN subpartition_count FORMAT 9999999 HEADING 'Subpart|Count';
COLUMN high_value FORMAT a50 HEADING 'Partition High Value';
COLUMN compression FORMAT a11 HEADING 'Key|Compression';
COLUMN product FORMAT a30 HEADING 'Installed Products';
COLUMN version FORMAT a12 HEADING 'Version';
COLUMN trigger_type FORMAT a16 HEADING 'Trigger Type';
COLUMN triggering_event FORMAT a26 HEADING 'Triggering Event';
COLUMN num_io_fts FORMAT 999,999,999 HEADING '(P)|Estimated|I/O''s for|FTS';
COLUMN num_io_firs FORMAT 999,999,999 HEADING -
          '(Q)|Estimated|I/O''s for full|index range|scan and|table access';
COLUMN bep_fts_firs FORMAT b99,999.9 HEADING -
          'Estimated|break even|point in %|between FTS|and FIRS|(P/Q)*100';
COLUMN username FORMAT a30 HEADING 'Username';
COLUMN default_tablespace FORMAT a30 HEADING 'Default Tablespace';
COLUMN temporary_tablespace FORMAT a30 HEADING 'Temporary Tablespace';
COLUMN contents FORMAT a9 HEADING 'Permanent|or|Temporary';
COLUMN logging FORMAT a9 HEADING 'Logging?';
COLUMN extent_management FORMAT a10 HEADING 'Extent|Management';
COLUMN allocation_type FORMAT a10 HEADING 'Allocation|Type';
COLUMN in_plan FORMAT a4 HEADING 'Used|in|Plan';
COLUMN plan_version FORMAT a10 HEADING 'plan|version';
COLUMN optimizer_used FORMAT a10 HEADING 'optimizer|used';
COLUMN plan_date FORMAT a20 HEADING 'plan creation|date and time';
COLUMN owner_tableview FORMAT a37 HEADING 'Owner.Table or View';
COLUMN policy_name FORMAT a30 HEADING 'Policy Name';
COLUMN policy_function FORMAT a55 HEADING 'Owner.Package.Function';
COLUMN chk_option FORMAT a3 HEADING 'Chk|Opt';
COLUMN enable FORMAT a6 HEADING 'Enable';
COLUMN pb_header FORMAT a80 HEADING 'Package Body Header';
COLUMN hiname FORMAT a24 HEADING 'host_instance|name';
COLUMN numcpus FORMAT 9999 HEADING 'CPUs';
COLUMN dbname FORMAT a9 HEADING 'db|name';
COLUMN dbversion FORMAT a17 HEADING 'db|version';
COLUMN istartup FORMAT a20 HEADING 'instance startup|date and time';
COLUMN multi_org FORMAT a5 HEADING 'multi|org';


/* VI. Populate COE Temporary Tables Section
   ========================================================================= */
SET term on;
PROMPT Computing Join Order...
SET term off;

BEGIN
    select to_number(value)
      into :db_block_size
      from V$PARAMETER
     where name = 'db_block_size'
       and rownum = 1;
    select to_number(value)
      into :db_file_multiblock_read_count
      from V$PARAMETER
     where name = 'db_file_multiblock_read_count'
       and rownum = 1;
    select substr(name,1,9)
      into :dbname
      from V$DATABASE
     where rownum = 1;
    select to_number(value)
      into :numcpus
      from V$PARAMETER
     where name = 'cpu_count'
       and rownum = 1;
    select substr(instance_name,1,16),
           substr(host_name,1,64),
           to_char(startup_time,'DD-MON-YYYY HH24:MI:SS'),
           substr(version,1,17)
      into :iname, :hname, :istartup, :dbversion
      from V$INSTANCE
     where rownum = 1;
    :multi_org := 'N/A';
END;
/
BEGIN
    select decode(multi_org_flag,'Y','YES','NO')
      into :multi_org
      from FND_PRODUCT_GROUPS
     where rownum = 1;
END;
/

INSERT                        -- Computing Join Order...
    INTO COE_JOIN_ORDER_XYZ
SELECT                        -- Table and Index, or Table Only
    CPT.EXECUTION_ORDER,      -- EXECUTION_ORDER_T
    NVL(CHILD.EXECUTION_ORDER,0),
                              -- EXECUTION_ORDER_I
    CPT.OBJECT_NAME,          -- TABLE_NAME
    DECODE(CHILD.OBJECT_NAME,NULL,'YES',NULL),
                              -- TABLE_ONLY
    NULL,                     -- INDEX_ONLY
    DECODE(CHILD.OBJECT_NAME,NULL,'('||CPT.OPTIONS||')',
           CHILD.OBJECT_NAME||' ('||CHILD.OPTIONS||')')
                              -- INDEX_METHOD
FROM
    COE_PLAN_TABLE_XYZ CHILD,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.ID                               = CHILD.PARENT_ID(+)
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'TABLE ACCESS'
AND NVL(CHILD.STATEMENT_ID,'COE_XPLAIN') = 'COE_XPLAIN'
AND NVL(CHILD.OPERATION,'INDEX')         = 'INDEX'
UNION ALL
SELECT                        -- Index Only
    0,                        -- EXECUTION_ORDER_T
    CPT.EXECUTION_ORDER,      -- EXECUTION_ORDER_I
    AI.TABLE_NAME,            -- TABLE_NAME
    NULL,                     -- TABLE_ONLY
    'YES',                    -- INDEX_ONLY
    CPT.OBJECT_NAME||' ('||CPT.OPTIONS||')'
                              -- INDEX_METHOD
FROM
    ALL_INDEXES    AI,
    COE_PLAN_TABLE_XYZ PARENT,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.PARENT_ID                        = PARENT.ID
AND CPT.OBJECT_OWNER                     = AI.OWNER
AND CPT.OBJECT_NAME                      = AI.INDEX_NAME
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'INDEX'
AND PARENT.STATEMENT_ID                  = 'COE_XPLAIN'
AND PARENT.OPERATION                    <> 'TABLE ACCESS'
AND PARENT.OPERATION                    <> 'AND-EQUAL'
UNION ALL
SELECT                        -- AND-EQUAL
    PARENT.EXECUTION_ORDER,   -- EXECUTION_ORDER_T
    CHILD.EXECUTION_ORDER,    -- EXECUTION_ORDER_I
    PARENT.OBJECT_NAME,       -- TABLE_NAME
    NULL,                     -- TABLE_ONLY
    NULL,                     -- INDEX_ONLY
    CHILD.OBJECT_NAME||' ('||CHILD.OPTIONS||')'
                              -- INDEX_METHOD
FROM
    COE_PLAN_TABLE_XYZ CHILD,
    COE_PLAN_TABLE_XYZ PARENT,
    COE_PLAN_TABLE_XYZ CPT
WHERE
    CPT.PARENT_ID                        = PARENT.ID
AND CPT.ID                               = CHILD.PARENT_ID
AND CPT.STATEMENT_ID                     = 'COE_XPLAIN'
AND CPT.OPERATION                        = 'AND-EQUAL'
AND PARENT.STATEMENT_ID                  = 'COE_XPLAIN'
AND PARENT.OPERATION                     = 'TABLE ACCESS'
AND CHILD.STATEMENT_ID                   = 'COE_XPLAIN'
AND CHILD.OPERATION                      = 'INDEX';

SET term on;
PROMPT Creating COE_TABLES...
SET term off;
INSERT            -- Creating COE_TABLES...
    INTO COE_TABLES_XYZ
SELECT
    OBJECT_OWNER, -- TABLE_OWNER
    OBJECT_NAME,  -- TABLE_NAME
    NULL,         -- TABLE_NUM
    NULL,         -- ROWS_COUNT
    'NO',         -- PARTITIONED
    NULL,         -- PERCENT
    NULL,         -- NUM_IO_FTS
    NULL          -- TABLESPACE_NAME
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID = 'COE_XPLAIN'
and OPERATION    = 'TABLE ACCESS'
UNION
SELECT
    TABLE_OWNER, -- TABLE_OWNER
    TABLE_NAME,  -- TABLE_NAME
    NULL,        -- TABLE_NUM
    NULL,        -- ROWS_COUNT
    'NO',        -- PARTITIONED
    NULL,        -- PERCENT
    NULL,        -- NUM_IO_FTS
    NULL         -- TABLESPACE_NAME
FROM
    ALL_INDEXES
WHERE
    (OWNER,
     INDEX_NAME)
IN  (SELECT DISTINCT
         OBJECT_OWNER,
         OBJECT_NAME
     FROM
         COE_PLAN_TABLE_XYZ
     WHERE
         STATEMENT_ID = 'COE_XPLAIN'
     and OPERATION    = 'INDEX');

UPDATE -- Creating COE_TABLES...
    COE_TABLES_XYZ CT
SET
    TABLE_NUM = ROWNUM,
    (PARTITIONED, TABLESPACE_NAME, NUM_IO_FTS) =
        (SELECT PARTITIONED, TABLESPACE_NAME,
         CEIL(AT.BLOCKS/:db_file_multiblock_read_count)
         FROM   ALL_TABLES AT
         WHERE  AT.OWNER      = CT.TABLE_OWNER
         AND    AT.TABLE_NAME = CT.TABLE_NAME),
    PERCENT =
        (SELECT 99.999999
         FROM   ALL_TABLES AT
         WHERE  AT.OWNER      = CT.TABLE_OWNER
         AND    AT.TABLE_NAME = CT.TABLE_NAME
         AND   (AT.IOT_TYPE  IS NULL
         OR     AT.IOT_TYPE  <> 'IOT_OVERFLOW')
         AND    AT.TEMPORARY  = 'N');

UPDATE /*+ ALL_ROWS */ -- Creating COE_TABLES...
    COE_TABLES_XYZ CT
SET
    NUM_IO_FTS =
        (SELECT SUM(CEIL(ATP.BLOCKS/:db_file_multiblock_read_count))
         FROM   ALL_TAB_PARTITIONS ATP
         WHERE  ATP.TABLE_OWNER = CT.TABLE_OWNER
         AND    ATP.TABLE_NAME  = CT.TABLE_NAME)
WHERE CT.PARTITIONED  = 'YES';

SET term on;
PROMPT Creating COE_INDEXES...
SET term off;
INSERT              -- Creating COE_INDEXES...
    INTO COE_INDEXES_XYZ
SELECT DISTINCT
    CT.TABLE_OWNER, -- TABLE_OWNER
    CT.TABLE_NAME,  -- TABLE_NAME
    CT.TABLE_NUM,   -- TABLE_NUM
    AI.OWNER,       -- INDEX_OWNER
    AI.INDEX_NAME,  -- INDEX_NAME
    NULL,           -- INDEX_NUM
    AI.PARTITIONED, -- PARTITIONED
    NULL,           -- ICOMPRESS
    NULL,           -- NUM_IO_FIRS
    NULL,           -- BEP_FTS_FIRS
    NULL,           -- IN_PLAN
    NULL,           -- ICOLUMNS
    AI.TABLESPACE_NAME
FROM
    ALL_INDEXES        AI,
    COE_TABLES_XYZ     CT
WHERE
    CT.TABLE_OWNER   = AI.TABLE_OWNER
AND CT.TABLE_NAME    = AI.TABLE_NAME;

UPDATE              -- Creating COE_INDEXES...
    COE_INDEXES_XYZ
SET
    INDEX_NUM = ROWNUM;

UPDATE              -- Creating COE_INDEXES...
    COE_INDEXES_XYZ CI
SET
    ICOMPRESS = (SELECT 'YES' FROM ALL_INDEXES AI
                 WHERE  AI.OWNER      = CI.INDEX_OWNER
                 AND    AI.INDEX_NAME = CI.INDEX_NAME
                 AND   (AI.UNIQUENESS = 'NONUNIQUE' OR
                       (AI.UNIQUENESS = 'UNIQUE' AND
                        EXISTS
                            (SELECT NULL
                             FROM   ALL_IND_COLUMNS AIC
                             WHERE  AIC.INDEX_OWNER     = AI.OWNER
                             AND    AIC.INDEX_NAME      = AI.INDEX_NAME
                             AND    AIC.COLUMN_POSITION = 2)))),
    NUM_IO_FIRS =
        (SELECT CEIL(AI.BLEVEL+AI.LEAF_BLOCKS+AI.CLUSTERING_FACTOR)
         FROM   ALL_INDEXES AI
         WHERE  AI.OWNER        = CI.INDEX_OWNER
         AND    AI.INDEX_NAME   = CI.INDEX_NAME)
WHERE
    CI.PARTITIONED <> 'YES';

UPDATE /*+ ALL_ROWS */-- Creating COE_INDEXES...
    COE_INDEXES_XYZ CI
SET
    NUM_IO_FIRS =
        (SELECT SUM(CEIL(AIP.BLEVEL+AIP.LEAF_BLOCKS+AIP.CLUSTERING_FACTOR))
         FROM   ALL_IND_PARTITIONS AIP
         WHERE  AIP.INDEX_OWNER = CI.INDEX_OWNER
         AND    AIP.INDEX_NAME  = CI.INDEX_NAME)
WHERE CI.PARTITIONED  = 'YES';

UPDATE                -- Creating COE_INDEXES...
    COE_INDEXES_XYZ CI
SET
    BEP_FTS_FIRS =
        (SELECT DECODE(CI.NUM_IO_FIRS,0,NULL,
                ROUND(CT.NUM_IO_FTS*100/CI.NUM_IO_FIRS,1))
         FROM   COE_TABLES_XYZ CT
         WHERE  CT.TABLE_OWNER = CI.TABLE_OWNER
         AND    CT.TABLE_NAME  = CI.TABLE_NAME),
    IN_PLAN =
        (SELECT 'YES'
         FROM   SYS.DUAL
         WHERE  EXISTS (SELECT NULL
                        FROM   COE_PLAN_TABLE_XYZ CPT
                        WHERE  CPT.OBJECT_OWNER = CI.INDEX_OWNER
                        AND    CPT.OBJECT_NAME  = CI.INDEX_NAME
                        AND    CPT.OPERATION    = 'INDEX'));

DECLARE
    c_index_owner VARCHAR2(30);
    c_index_name  VARCHAR2(30);
    c_column_name VARCHAR2(30);
    cursor C_columns is
        SELECT -- Creating COE_INDEXES...
               AIC.INDEX_OWNER, AIC.INDEX_NAME, AIC.COLUMN_NAME
        FROM   ALL_IND_COLUMNS AIC,
               COE_INDEXES_XYZ CI
        WHERE  AIC.INDEX_OWNER  = CI.INDEX_OWNER
        AND    AIC.INDEX_NAME   = CI.INDEX_NAME
        ORDER BY AIC.INDEX_OWNER, AIC.INDEX_NAME, AIC.COLUMN_POSITION;
BEGIN
    OPEN C_columns;
    LOOP
        FETCH C_columns into c_index_owner, c_index_name, c_column_name;
        EXIT when C_columns%NOTFOUND;
        UPDATE -- Creating COE_INDEXES...
               COE_INDEXES_XYZ SET ICOLUMNS = ICOLUMNS||c_column_name||' '
        WHERE  INDEX_OWNER = c_index_owner
        AND    INDEX_NAME  = c_index_name;
    END LOOP;
    CLOSE C_columns;
END;
/

UPDATE -- Creating COE_INDEXES...
    COE_PLAN_TABLE_XYZ CPT
SET
    CPT.ICOLUMNS = (SELECT CI.ICOLUMNS
                    FROM   COE_INDEXES_XYZ CI
                    WHERE  CI.INDEX_OWNER = CPT.OBJECT_OWNER
                    AND    CI.INDEX_NAME  = CPT.OBJECT_NAME)
WHERE
    CPT.OPERATION = 'INDEX'
AND CPT.OPTIONS IN ('RANGE SCAN','UNIQUE SCAN');

UPDATE -- Updating Operation_id
    COE_PLAN_TABLE_XYZ CPT
SET
    CPT.VERSION = (LENGTH(CPT.OPERATION||CPT.OPTIONS||CPT.OBJECT_OWNER||
                          CPT.OBJECT_NAME||CPT.OBJECT_TYPE||CPT.ICOLUMNS||
                          CPT.PARTITION_START||CPT.PARTITION_STOP)+
                   NVL(CPT.PARENT_ID,0)+CPT.ID+CPT.POSITION+
                   NVL(CPT.PARTITION_ID,0))*CPT.EXECUTION_ORDER
WHERE
    CPT.ID <> 0;

BEGIN
    select sum(version)
      into :plan_version
      from COE_PLAN_TABLE_XYZ;
END;
/

SET hea off pages 0;
SPOOL coe_xplain_tables.sql;
SELECT -- Computing COUNT(*)...
    'UPDATE COE_TABLES_XYZ CT SET ROWS_COUNT=(SELECT '||
    'COUNT(*) FROM '||TABLE_OWNER||'.'||TABLE_NAME||
    ') WHERE CT.TABLE_OWNER='''||
    TABLE_OWNER||''' AND CT.TABLE_NAME='''||TABLE_NAME||''';'
FROM
    COE_TABLES_XYZ
WHERE
    NVL(substr(upper('&&include_count'),1,1),'Y') = 'Y';
SPOOL OFF;

SET term on;
PROMPT Computing COUNT(*)...
SET term off;
START coe_xplain_tables.sql;

SET term on;
PROMPT Creating COE_SEGMENTS... (it may take a few minutes, please wait)...
SET term off;
INSERT -- Creating COE_SEGMENTS...
    INTO COE_SEGMENTS_XYZ
SELECT /*+ USE_HASH(DS) */
    DS.OWNER,
    SUBSTR(DS.SEGMENT_NAME,1,30),
    DS.PARTITION_NAME,
    DS.SEGMENT_TYPE,
    DS.TABLESPACE_NAME,
    DS.BYTES,
    DS.BLOCKS,
    DS.EXTENTS,
    DS.INITIAL_EXTENT,
    DS.NEXT_EXTENT,
    DS.MIN_EXTENTS,
    DS.MAX_EXTENTS,
    DS.PCT_INCREASE,
    DS.FREELISTS,
    DS.FREELIST_GROUPS
FROM
    DBA_SEGMENTS DS
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND (DS.OWNER, SUBSTR(DS.SEGMENT_NAME,1,30)) IN
    (SELECT CT.TABLE_OWNER, CT.TABLE_NAME
     FROM COE_TABLES_XYZ CT
     UNION ALL
     SELECT CI.INDEX_OWNER, CI.INDEX_NAME
     FROM COE_INDEXES_XYZ CI);

SET term on;
PROMPT Creating COE_EXTENTS... (it may take several minutes, be patient)...
SET term off;
INSERT -- Creating COE_EXTENTS...
    INTO COE_EXTENTS_XYZ
SELECT /*+ ALL_ROWS */
    DE.OWNER,
    SUBSTR(DE.SEGMENT_NAME,1,30),
    DE.PARTITION_NAME,
    DE.SEGMENT_TYPE,
    DE.EXTENT_ID,
    DE.FILE_ID,
    DE.BLOCK_ID,
    DE.BYTES,
    DE.BLOCKS
FROM
    DBA_EXTENTS DE
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND (DE.OWNER, SUBSTR(DE.SEGMENT_NAME,1,30)) IN
    (SELECT CT.TABLE_OWNER, CT.TABLE_NAME
     FROM COE_TABLES_XYZ CT
     UNION ALL
     SELECT CI.INDEX_OWNER, CI.INDEX_NAME
     FROM COE_INDEXES_XYZ CI);

SPOOL coe_xplain_histograms.sql;
SELECT -- Creating COE_HISTOGRAMS...
    'INSERT INTO COE_HISTOGRAMS_XYZ '||
    'SELECT '||TABLE_NUM||','''||TABLE_OWNER||''', '''||
     TABLE_NAME||''', COLUMN_NAME, ENDPOINT_NUMBER, '||
    'ENDPOINT_VALUE, SUBSTR(ENDPOINT_ACTUAL_VALUE,1,30), NULL '||
    'FROM ALL_TAB_HISTOGRAMS WHERE OWNER='''||TABLE_OWNER||
    ''' AND TABLE_NAME='''||TABLE_NAME||''';'
FROM
    COE_TABLES_XYZ;
SPOOL OFF;

SET term on;
PROMPT Creating COE_HISTOGRAMS...
SET term off;
START coe_xplain_histograms.sql;
UPDATE -- Creating COE_HISTOGRAMS...
    COE_HISTOGRAMS_XYZ
SET
    ENDPOINT_JULIAN = TRUNC(ENDPOINT_VALUE)
WHERE
    ENDPOINT_VALUE BETWEEN 1 AND 5373484;

SET term on;
PROMPT Creating COE_HISTOGRAM_COLS...
SET term off;
INSERT -- Columns in FND_HISTOGRAM_COLS (only for Apps 11i)
    INTO COE_HISTOGRAM_COLS_XYZ
SELECT DISTINCT     -- Creating COE_HISTOGRAM_COLS...
    CT.TABLE_NUM,   -- Table Number
    FHC.TABLE_NAME, -- Table Name
    FHC.COLUMN_NAME,-- Column Name
    FHC.PARTITION,  -- Partition
    FHC.HSIZE       -- Hsize
FROM
    COE_TABLES_XYZ     CT,
    FND_HISTOGRAM_COLS FHC
WHERE
    CT.TABLE_NAME  = FHC.TABLE_NAME;

INSERT -- Indexed Columns and Columns with existing Histograms
    INTO COE_HISTOGRAM_COLS_XYZ
SELECT              -- Creating COE_HISTOGRAM_COLS... Indexed Columns
    CI.TABLE_NUM,   -- Table Number
    AIC.TABLE_NAME, -- Table Name
    AIC.COLUMN_NAME,-- Column Name
    NULL,           -- Partition
    NULL            -- Hsize
FROM
    ALL_IND_COLUMNS  AIC,
    COE_INDEXES_XYZ  CI
WHERE
    CI.INDEX_OWNER = AIC.INDEX_OWNER
AND CI.INDEX_NAME  = AIC.INDEX_NAME
AND NOT EXISTS (SELECT NULL
                FROM   COE_HISTOGRAM_COLS_XYZ CHC
                WHERE  CHC.TABLE_NAME   = AIC.TABLE_NAME
                AND    CHC.COLUMN_NAME  = AIC.COLUMN_NAME)
UNION
SELECT             -- Creating COE_HISTOGRAM_COLS... Columns wexisting Hist
    CH.TABLE_NUM,  -- Table Number
    CH.TABLE_NAME, -- Table Name
    CH.COLUMN_NAME,-- Column Name
    NULL,          -- Partition
    NULL           -- Hsize
FROM
    COE_HISTOGRAMS_XYZ CH
WHERE
    NOT EXISTS (SELECT NULL
                FROM   COE_HISTOGRAM_COLS_XYZ CHC
                WHERE  CHC.TABLE_NAME   = CH.TABLE_NAME
                AND    CHC.COLUMN_NAME  = CH.COLUMN_NAME)
GROUP BY
    CH.TABLE_NUM,
    CH.TABLE_NAME,
    CH.COLUMN_NAME
HAVING
    MAX(ENDPOINT_NUMBER) > 1;

SET term on;
PROMPT Creating COE_POLICIES...
SET term off;
INSERT -- Table or View Policies
    INTO COE_POLICIES_XYZ
SELECT DISTINCT
    AP.OBJECT_OWNER,
    AP.OBJECT_NAME,
    AP.POLICY_NAME,
    AP.PF_OWNER,
    AP.PACKAGE,
    AP.FUNCTION,
    AP.SEL,
    AP.INS,
    AP.UPD,
    AP.DEL,
    AP.CHK_OPTION,
    AP.ENABLE,
    NULL -- PB_HEADER
FROM
    ALL_POLICIES        AP,
    COE_PLAN_TABLE_XYZ  CPT
WHERE
    AP.OBJECT_OWNER      = CPT.OBJECT_OWNER
AND AP.OBJECT_NAME       = CPT.OBJECT_NAME
AND (CPT.OPERATION LIKE 'TABLE%' OR
     CPT.OPERATION LIKE 'VIEW%');

UPDATE COE_POLICIES_XYZ CP -- Updating package body $Header for Policies
   SET CP.PB_HEADER = (SELECT SUBSTR(SR.TEXT,1,80) pb_header
                         FROM ALL_SOURCE SR
                        WHERE SR.OWNER = CP.pf_owner
                          AND SR.NAME  = CP.package
                          AND SR.TYPE  = 'PACKAGE BODY'
                          AND UPPER(SR.TEXT) LIKE ('%$%HEADER%')
                          AND ROWNUM   = 1);

SET term on;
PROMPT Creating COE_PARAMETERS...
SET term off;

BEGIN
    IF SUBSTR(:dbversion,1,5) IN ('8.1.6','8.1.7','9.0.1') THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_fast_full_scan_enabled',null,'FALSE',null,'TRUE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_like_with_bind_as_equality',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_shared_pool_reserved_min_alloc',null,null,'4100-5000','5000');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_table_scan_cost_plus_one',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_trace_files_public',null,null,'TRUE','FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('aq_tm_processes',null,'1',null,'0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('cursor_sharing',null,null,'EXACT','EXACT');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('db_block_buffers',null,'5000 or more',null,'48 MB');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('db_block_size',null,null,'8192','2048');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('db_file_multiblock_read_count',null,'8',null,'8');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('db_files',null,'500 or more',null,'200');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('dml_locks',null,'500 or more',null,'4 x transactions');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('enqueue_resources',null,'5000 or more',null,'derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('hash_area_size',null,null,'512000-4096000','2 x sort_area_size');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('java_pool_size',null,'50000000 or more',null,'20000');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('job_queue_processes',null,'5 or more',null,'0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('log_buffer',null,'1048576 or more',null,'524288');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('log_checkpoint_interval',null,null,'100000 or more','os dependent');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('log_checkpoint_timeout',null,null,'1200','900');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('max_enabled_roles',null,'40 or more',null,'20');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('nls_date_format',null,'DD-MON-RR',null,'derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('nls_language',null,null,'AMERICAN','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('nls_numeric_characters',null,null,'.,','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('nls_sort',null,null,'BINARY','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('nls_territory',null,null,'AMERICA','os dependent');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('open_cursors',null,'500 or more',null,'50');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_index_caching',null,'0',null,'0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_index_cost_adj',null,'100',null,'100');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_mode',null,'CHOOSE',null,'CHOOSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('parallel_max_servers',null,null,'2 x cpu_count','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('parallel_min_percent',null,null,'0','0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('parallel_min_servers',null,null,'0','0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('parallel_threads_per_cpu',null,null,'2','2');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('processes',null,'75 or more','max active users','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('query_rewrite_enabled',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('row_locking',null,'ALWAYS',null,'ALWAYS');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('sessions',null,'150 or more','2 x processes','derived');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('shared_pool_reserved_size',null,null,'10% shared_pool',
                                                '5% shared_pool');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('shared_pool_size',null,null,'300000000','16 or 64 MB');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('sort_area_size',null,null,'256000-2048000','65536');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('sql_trace',null,null,'FALSE','FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('timed_statistics',null,null,'TRUE','FALSE');
    END IF;
    IF SUBSTR(:dbversion,1,5) IN ('8.1.6','8.1.7') THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_complex_view_merging',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_optimizer_mode_force',null,'TRUE',null,'TRUE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_optimizer_undo_changes',null,'FALSE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_ordered_nested_loop',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_push_join_predicate',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_push_join_union_view',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_sort_elimination_cost_ratio',null,'5',null,'0');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('always_anti_join',null,'NESTED_LOOPS',null,'NESTED_LOOPS');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('always_semi_join',null,'NESTED_LOOPS',null,'NESTED_LOOPS');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('max_dump_file_size',null,null,'UNLIMITED','5 MB');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_percent_parallel',null,'0',null,'0');
    END IF;
    IF SUBSTR(:dbversion,1,5) IN ('8.1.7','9.0.1') THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_system_trig_enabled',null,'TRUE',null,'TRUE');
    END IF;
    IF SUBSTR(:dbversion,1,5) = '8.1.6' THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_or_expand_nvl_predicate',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_use_column_stats_for_function',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('compatible',null,'8.1.6',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_features_enable',null,'8.1.6',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_max_permutations',null,'79000',null,'80000');
    END IF;
    IF SUBSTR(:dbversion,1,5) = '8.1.7' THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_sqlexec_progression_cost',null,'0',null,'1000');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_or_expand_nvl_predicate',null,'TRUE',null,'TRUE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_use_column_stats_for_function',null,'TRUE',null,'TRUE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('compatible',null,'8.1.7',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_features_enable',null,'8.1.7',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_new_initial_join_orders',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_max_permutations',null,'2000',null,'80000');
    END IF;
    IF SUBSTR(:dbversion,1,5) = '9.0.1' THEN
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('compatible',null,'9.0.1',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_features_enable',null,'9.0.1',null,'none');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('_system_trig_enabled',null,'TRUE',null,'TRUE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('O7_DICTIONARY_ACCESSIBILITY',null,'TRUE',null,'FALSE');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('max_dump_file_size',null,null,'UNLIMITED','UNLIMITED');
       INSERT INTO COE_PARAMETERS_XYZ VALUES
        ('optimizer_max_permutations',null,'2000',null,'2000');
    END IF;
END;
/

UPDATE COE_PARAMETERS_XYZ CP
   SET CP.VALUE = (SELECT SUBSTR(VP.VALUE,1,512)
                     FROM V$PARAMETER VP
                    WHERE VP.NAME = CP.NAME);

INSERT INTO COE_PARAMETERS_XYZ
SELECT SUBSTR(VP.NAME,1,64),SUBSTR(VP.VALUE,1,512),NULL,NULL,NULL
  FROM V$PARAMETER VP
 WHERE VP.ISDEFAULT = 'FALSE'
   AND NOT EXISTS (SELECT NULL FROM COE_PARAMETERS_XYZ CP
                    WHERE CP.NAME = VP.NAME);

COMMIT;

SET term on;
PROMPT Creating coe_verify_stats.sql script...
SET term off;
SPOOL coe_verify_stats.sql;
SELECT -- Creating coe_verify_stats.sql script...
    'EXEC FND_STATS.VERIFY_STATS('||
    'schemaname=>'''||TABLE_OWNER||''','||
    'tablelist=>'''||TABLE_NAME||''');'
FROM
    COE_TABLES_XYZ;
SPOOL OFF;
SPOOL coe_verify_stats.txt;
START coe_verify_stats.sql;
SPOOL OFF;

SET term on;
PROMPT Creating coe_fix_stats.sql script...
SET term off;
SPOOL coe_fix_stats.sql;
COLUMN DUMMY1 FORMAT A30 NOPRINT;
SELECT -- Creating coe_fix_stats.sql script...
    TABLE_OWNER||TABLE_NAME||'1' DUMMY1, -- Back up old Stats
    SUBSTR('EXEC FND_STATS.BACKUP_TABLE_STATS('||
    'schemaname=>'''||TABLE_OWNER||''','||
    'tabname=>'''||TABLE_NAME||''','||
    'statid=>''COE ''||TO_CHAR(SYSDATE,''YYYYMMDD:HH24MI'')'||
    ');',1,200)
FROM
    COE_TABLES_XYZ
WHERE
    PERCENT IS NOT NULL
UNION ALL
SELECT
    TABLE_OWNER||TABLE_NAME||'2' DUMMY1, -- Drops old Stats
    SUBSTR('EXEC DBMS_STATS.DELETE_TABLE_STATS('||
    'ownname=>'''||TABLE_OWNER||''','||
    'tabname=>'''||TABLE_NAME||''');',1,200)
FROM
    COE_TABLES_XYZ
WHERE
    PERCENT IS NOT NULL
UNION ALL
SELECT
    TABLE_OWNER||TABLE_NAME||'3' DUMMY1, -- BLOCKS, EMPTY_BLOCKS,
    SUBSTR('ANALYZE TABLE '||            -- AVG_SPACE, AVG_ROW_LEN
    TABLE_OWNER||'.'||TABLE_NAME||
    ' ESTIMATE STATISTICS SAMPLE 1 ROWS;',1,200)
FROM
    COE_TABLES_XYZ
WHERE
    PERCENT IS NOT NULL
UNION ALL
SELECT
    TABLE_OWNER||TABLE_NAME||'4' DUMMY1, -- Gather new Stats
    SUBSTR('EXEC FND_STATS.GATHER_TABLE_STATS('||
    'ownname=>'''||TABLE_OWNER||''','||
    'tabname=>'''||TABLE_NAME||''','||
    'percent=>'||TO_CHAR(PERCENT)||','||
    'granularity=>'||DECODE(PARTITIONED,'YES','''PARTITION''','''DEFAULT''')||
    ');',1,200)
FROM
    COE_TABLES_XYZ
WHERE
    PERCENT IS NOT NULL
ORDER BY 1;
SPOOL OFF;

SET term on;
PROMPT Creating coe_rebuild_indexes.sql script...
SET term off;
SPOOL coe_rebuild_indexes.sql;
SELECT -- Creating coe_rebuild_indexes.sql script...
    'ALTER INDEX '||CI.INDEX_OWNER||'.'||CI.INDEX_NAME||' REBUILD '||
    'INITRANS 2 PCTFREE 0 '||DECODE(CI.ICOMPRESS,'YES','COMPRESS ')||
    'COMPUTE STATISTICS;'
FROM
    COE_INDEXES_XYZ    CI
WHERE
    CI.PARTITIONED <> 'YES'
UNION ALL
SELECT /*+ ALL_ROWS */
    'ALTER INDEX '||CI.INDEX_OWNER||'.'||CI.INDEX_NAME||' REBUILD '||
    'PARTITION '||AIP.PARTITION_NAME||' '||
    'INITRANS 2 PCTFREE 0 COMPUTE STATISTICS;'
FROM
    ALL_IND_PARTITIONS AIP,
    COE_INDEXES_XYZ    CI
WHERE
    AIP.INDEX_OWNER = CI.INDEX_OWNER
AND AIP.INDEX_NAME  = CI.INDEX_NAME
AND CI.PARTITIONED  = 'YES';
SPOOL OFF;

SET term on;
PROMPT Creating coe_create_tables.sql script...
SET term off;
SPOOL coe_create_tables.sql;
DECLARE
    sql0          VARCHAR2(1000);
    v_table_owner coe_tables_xyz.table_owner%TYPE;
    v_table_name  coe_tables_xyz.table_name%TYPE;
    v_count       NUMBER;
    CURSOR c_tables IS
        SELECT ct.table_owner, ct.table_name
          FROM coe_tables_xyz    ct
         WHERE ct.partitioned = 'NO'
         ORDER BY ct.table_owner, ct.table_name;
    CURSOR c_columns IS
        SELECT atc.column_name, atc.data_type, atc.data_length,
               atc.data_precision, atc.data_scale, atc.nullable
          FROM all_tab_columns   atc
         WHERE atc.owner      =  v_table_owner
           AND atc.table_name =  v_table_name
         ORDER BY atc.column_id;
BEGIN
    sql0:='/*$Header: coe_create_tables.sql (8.1-9.0) '||
          TO_CHAR(sysdate,'YYYY/MM/DD')||
          '      gen by coe_xplain.sql   csierra bde $*/';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='/* Note: Do not execute, unless requested by Oracle Support.  '||
          'Edit accordingly before execution */';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SET echo on;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SPOOL coe_create_tables.txt;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    FOR t1 IN c_tables LOOP
        v_table_owner := t1.table_owner;
        v_table_name  := t1.table_name;
        v_count       := 0;
        sql0:='/**/';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:='/**/ CREATE TABLE '||RPAD(LOWER(t1.table_name),31)||
              '/* '||t1.table_owner||' */';
        DBMS_OUTPUT.PUT_LINE(sql0);
        FOR t2 IN c_columns LOOP
            v_count := v_count + 1;
            sql0:='/**/ ';
            IF v_count = 1 THEN
               sql0:=RPAD(sql0||'(',18);
            ELSE
               sql0:=RPAD(sql0||',',18);
            END IF;
            sql0:=sql0||RPAD(LOWER(t2.column_name),31)||t2.data_type;
            IF t2.data_type IN ('VARCHAR2','CHAR') THEN
               sql0:=sql0||'('||t2.data_length||')';
            ELSIF t2.data_type = 'NUMBER' THEN
               IF t2.data_precision IS NOT NULL THEN
                  sql0:=sql0||'('||t2.data_precision;
                  IF t2.data_scale > 0 THEN
                     sql0:=sql0||','||t2.data_scale;
                  END IF;
                  sql0:=sql0||')';
               END IF;
            END IF;
            IF t2.nullable = 'N' THEN
               sql0:=RPAD(sql0,70)||'NOT NULL';
            END IF;
            DBMS_OUTPUT.PUT_LINE(sql0);
        END LOOP;
        sql0:='/**/ );';
        DBMS_OUTPUT.PUT_LINE(sql0);
    END LOOP;
    sql0:='SPOOL OFF;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SET echo off;';
    DBMS_OUTPUT.PUT_LINE(sql0);
END;
/
SPOOL OFF;

SET term on;
PROMPT Creating coe_recreate_indexes.sql script...
SET term off;
SPOOL coe_recreate_indexes.sql;
DECLARE
    sql0 VARCHAR2(1000);
    col1 all_ind_columns.column_name%TYPE;
    asc1 all_ind_columns.descend%TYPE;
    irec all_indexes%ROWTYPE;
    CURSOR C_index IS
        SELECT ai.*
          FROM all_indexes     ai,
               coe_indexes_xyz ci
         WHERE ai.owner       = ci.index_owner
           AND ai.index_name  = ci.index_name
           AND ai.index_type  = 'NORMAL'
           AND ai.partitioned = 'NO';
    CURSOR C_columns IS
        SELECT aic.column_name, aic.descend
          FROM all_ind_columns aic
         WHERE aic.index_owner     = irec.owner
           AND aic.index_name      = irec.index_name
           AND aic.column_position > 1
         ORDER BY aic.column_position;
BEGIN
    sql0:='/*$Header: coe_recreate_indexes.sql (8.1-9.0) ';
    sql0:=sql0||TO_CHAR(sysdate,'YYYY/MM/DD');
    sql0:=sql0||'   gen by coe_xplain.sql   csierra bde $*/';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='/* Note: Do not execute, unless requested by Oracle Support.  ';
    sql0:=sql0||'Edit accordingly before execution */';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SET echo on;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SPOOL coe_recreate_indexes.txt;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    OPEN C_index;
    LOOP
        FETCH C_index INTO irec;
        EXIT WHEN C_index%NOTFOUND;
        sql0:='/**/';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/ DROP',19)||'INDEX '||irec.owner||'.';
        sql0:=sql0||irec.index_name||';';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:='/**/ CREATE ';
        IF irec.uniqueness = 'UNIQUE' THEN
           sql0:=sql0||'UNIQUE ';
        ELSE
           sql0:=sql0||'       ';
        END IF;
        sql0:=sql0||'INDEX '||irec.owner||'.'||irec.index_name;
        sql0:=sql0||' ON '||irec.table_owner||'.'||irec.table_name;
        DBMS_OUTPUT.PUT_LINE(sql0);
        SELECT aic.column_name, aic.descend
          INTO col1, asc1
          FROM all_ind_columns aic
         WHERE aic.index_owner     = irec.owner
           AND aic.index_name      = irec.index_name
           AND aic.column_position = 1;
        sql0:=RPAD('/**/',25)||'( '||col1||' '||asc1;
        DBMS_OUTPUT.PUT_LINE(sql0);
        OPEN C_columns;
        LOOP
            FETCH C_columns INTO col1, asc1;
            EXIT WHEN C_columns%NOTFOUND;
            sql0:=RPAD('/**/',25)||', '||col1||' '||asc1;
            DBMS_OUTPUT.PUT_LINE(sql0);
        END LOOP;
        CLOSE C_columns;
        sql0:=RPAD('/**/',25)||')';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/',25)||'PCTFREE '||irec.pct_free||' ';
        sql0:=sql0||'INITRANS '||irec.ini_trans||' ';
        sql0:=sql0||'MAXTRANS '||irec.max_trans;
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/',25)||'STORAGE ( ';
        sql0:=sql0||'INITIAL '||irec.initial_extent||' ';
        sql0:=sql0||'NEXT '||irec.next_extent||' ';
        sql0:=sql0||'MINEXTENTS '||irec.min_extents||' ';
        sql0:=sql0||'MAXEXTENTS '||irec.max_extents;
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/',35)||'PCTINCREASE '||irec.pct_increase||' ';
        sql0:=sql0||'FREELISTS '||irec.freelists||' ';
        sql0:=sql0||'FREELIST GROUPS '||irec.freelist_groups||' ';
        sql0:=sql0||')';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/',25);
        sql0:=sql0||'NOLOGGING ';
        sql0:=sql0||'COMPUTE STATISTICS ';
        sql0:=sql0||'TABLESPACE '||irec.tablespace_name||' ';
        IF irec.compression = 'ENABLED' THEN
           sql0:=sql0||'COMPRESS '||irec.prefix_length||' ';
        END IF;
        sql0:=sql0||';';
        DBMS_OUTPUT.PUT_LINE(sql0);
        sql0:=RPAD('/**/ ALTER',19)||'INDEX '||irec.owner||'.';
        sql0:=sql0||irec.index_name||' LOGGING;';
        DBMS_OUTPUT.PUT_LINE(sql0);
    END LOOP;
    CLOSE C_index;
    sql0:='SPOOL OFF;';
    DBMS_OUTPUT.PUT_LINE(sql0);
    sql0:='SET echo off;';
    DBMS_OUTPUT.PUT_LINE(sql0);
END;
/
SPOOL OFF;

SET term on;
PROMPT Creating coe_start_view.sql script...
SET term off;
SPOOL coe_start_view.sql;
SELECT DISTINCT
    'START coe_view.sql '||CPT.OBJECT_NAME||';'
FROM
    COE_PLAN_TABLE_XYZ  CPT
WHERE
    CPT.OPERATION     LIKE 'VIEW%'
AND CPT.OBJECT_OWNER     = USER
AND CPT.OBJECT_NAME IS NOT NULL;
SPOOL OFF;


/* VII. Creates coe_xplain_sql.txt spool file with Explain Plan
   ========================================================================= */
SET hea on pages 10000;
SPOOL coe_xplain_&&1;
SET long 50 term on recsep off;

PROMPT ========================================================================
PROMPT coe_xplain.sql - Enhanced Explain Plan for given SQL statement (8.1-9.0)
PROMPT ========================================================================

COMMIT;
get &&1
0 explain plan set statement_id = 'DUMMY' into COE_PLAN_TABLE_XYZ for
/
ROLLBACK;

SELECT
    TO_CHAR(:plan_version)                        PLAN_VERSION,
    DECODE(POSITION,null,'Rule','Cost')||'-based' OPTIMIZER_USED,
    to_char(sysdate,'DD-MON-YYYY HH24:MI:SS')     PLAN_DATE,
    substr(upper(:hname||'_'||:iname),1,24)       HINAME,
    :numcpus                                      NUMCPUS,
    :dbname                                       DBNAME,
    :dbversion                                    DBVERSION,
    :istartup                                     ISTARTUP,
    :multi_org                                    MULTI_ORG
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID    = 'COE_XPLAIN'
AND ID              = 0;

SELECT -- VII. Creates coe_xplain_&&1 spool file with Explain Plan (1st)
    DECODE(OPERATION,'SORT','SET','HASH JOIN','S/R','ROW') typ,  -- Op Type
    EXECUTION_ORDER, -- Processing Order
    lpad(' ',LEVEL+1,rpad(' ',80,'....|'))||OPERATION||' '|| -- Operation
    DECODE(OPTIONS,NULL,'',DECODE(SUBSTR(OPTIONS,1,4),'FULL',
           '***('||OPTIONS||')*** ','('||OPTIONS||') '))|| -- Options
    DECODE(OBJECT_OWNER,null,'','OF '''||OBJECT_OWNER||'.')|| -- Owner
    DECODE(OBJECT_NAME,null,'',OBJECT_NAME||''' ')|| -- Object Name
    DECODE(OBJECT_TYPE,null,'','('||OBJECT_TYPE||') ')|| -- Object Type
    DECODE(ID,0,'Opt_Mode:')||
    DECODE(OPTIMIZER,null,'','ANALYZED','',OPTIMIZER)
    query_plan -- Explain Plan
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID    = 'COE_XPLAIN'
CONNECT BY PRIOR ID = PARENT_ID
AND STATEMENT_ID    = 'COE_XPLAIN'
START WITH ID       = 0
AND STATEMENT_ID    = 'COE_XPLAIN'
ORDER BY ID,POSITION;

SELECT -- VII. Creates coe_xplain_&&1 spool file with Explain Plan (2nd)
    lpad(' ',LEVEL+1,rpad(' ',80,'....|'))||
    DECODE(OPERATION,'INDEX',DECODE(OPTIONS,
    'UNIQUE SCAN','IUS '||OBJECT_NAME||' [ '||ICOLUMNS||']',
    'RANGE SCAN','IRS '||OBJECT_NAME||' [ '||ICOLUMNS||']',
    'FULL SCAN','IFS '||OBJECT_NAME||' [ '||ICOLUMNS||']',
    OPERATION||' '||DECODE(OPTIONS,NULL,'','('||OPTIONS||') ')||OBJECT_NAME),
    OPERATION||' '||DECODE(OPTIONS,NULL,'','('||OPTIONS||') ')||OBJECT_NAME)
    query_plan -- Explain Plan
FROM
    COE_PLAN_TABLE_XYZ
WHERE
    STATEMENT_ID    = 'COE_XPLAIN'
CONNECT BY PRIOR ID = PARENT_ID
AND STATEMENT_ID    = 'COE_XPLAIN'
START WITH ID       = 0
AND STATEMENT_ID    = 'COE_XPLAIN'
ORDER BY ID,POSITION;

PROMPT
PROMPT IRS - Index Range Scan.  IUS - Index Unique Scan.  IFS=Index Full Scan.

/* VII.a Displays CBO Extended Plan if CBO has been used                     */
/* ========================================================================= */
BEGIN
    select count(*) into :CBO_PLAN from COE_PLAN_TABLE_XYZ
    where cost is not null;
END;
/
Rem $Header: utlxplp.sql 25-may-98.16:30:41 bdagevil Exp $ CBO Extended Plan
select -- VII.a Displays CBO Extended Plan if CBO has been used
    '|Exec'||
    '| Operation                         |  Object Name               '||
    '|  Rows | Bytes|  Cost  |  TQ  '||
    '|IN-OUT| PQ Distrib | Pstart| Pstop |'
as "CBO Extended Plan"
from sys.dual
where :CBO_PLAN > 0
union all
select
    '------------------------------'||
    '-----------------------------------------------------------------------'||
    '-------------------------------------'
from sys.dual
where :CBO_PLAN > 0
union all
select * from
(select /*+ no_merge */
    '|'||lpad(execution_order,4,' ')||
    rpad('| '||substr(lpad(' ',1*(level-1))||operation||
    decode(options, null,'',' '||options), 1, 36), 36, ' ')||'|'||
    rpad(substr(object_name||' ',1, 28), 28, ' ')||'|'||
    lpad(decode(cardinality,null,'  ',
    decode(sign(cardinality-1000), -1, cardinality||' ',
    decode(sign(cardinality-1000000), -1, trunc(cardinality/1000)||'K',
    decode(sign(cardinality-1000000000), -1, trunc(cardinality/1000000)||'M',
    trunc(cardinality/1000000000)||'G')))), 7, ' ') || '|' ||
    lpad(decode(bytes,null,' ',
    decode(sign(bytes-1024), -1, bytes||' ',
    decode(sign(bytes-1048576), -1, trunc(bytes/1024)||'K',
    decode(sign(bytes-1073741824), -1, trunc(bytes/1048576)||'M',
    trunc(bytes/1073741824)||'G')))), 6, ' ') || '|' ||
    lpad(decode(cost,null,' ',
    decode(sign(cost-10000000), -1, cost||' ',
    decode(sign(cost-1000000000), -1, trunc(cost/1000000)||'M',
    trunc(cost/1000000000)||'G'))), 8, ' ') || '|' ||
    lpad(decode(object_node,null,' ',
    substr(object_node,length(object_node)-3,1) || ',' ||
    substr(object_node,length(object_node)-1,2))||' ', 6, ' ') || '|' ||
    lpad(decode(other_tag, null,' ',
    decode(other_tag,'PARALLEL_TO_SERIAL', ' P->S',
    decode(other_tag, 'PARALLEL_TO_PARALLEL', ' P->P',
    decode(other_tag, 'PARALLEL_COMBINED_WITH_PARENT', ' PCWP',
    decode(other_tag, 'PARALLEL_FROM_SERIAL', ' S->P',
    decode(other_tag, 'PARALLEL_COMBINED_WITH_CHILD', ' PCWC',
    decode(other_tag,null,' ',other_tag)))))))||' ', 6, ' ') || '|' ||
    rpad(' '||decode(distribution, null,' ',
    decode(distribution, 'PARTITION (ROWID)', 'PART (RID)',
    decode(distribution, 'PARTITION (KEY)', 'PART (KEY)',
    decode(distribution, 'ROUND-ROBIN', 'RND-ROBIN',
    decode(distribution, 'BROADCAST', 'BROADCAST', distribution))))), 12, ' ')
    || '|' ||
    lpad(decode(partition_start, 'ROW LOCATION', 'ROWID',
    decode(partition_start, 'KEY', 'KEY', decode(partition_start,
    'KEY(INLIST)', 'KEY(I)', decode(substr(partition_start, 1, 6),
    'NUMBER', substr(substr(partition_start, 8, 10), 1,
    length(substr(partition_start, 8, 10))-1),
    decode(partition_start,null,' ',partition_start)))))||' ', 7, ' ')
    || '|' ||
    lpad(decode(partition_stop, 'ROW LOCATION', 'ROW L',
    decode(partition_stop, 'KEY', 'KEY', decode(partition_stop,
    'KEY(INLIST)', 'KEY(I)', decode(substr(partition_stop, 1, 6),
    'NUMBER', substr(substr(partition_stop, 8, 10), 1,
    length(substr(partition_stop, 8, 10))-1),
    decode(partition_stop,null,' ',partition_stop)))))||' ', 7, ' ')||'|'
    as "Explain plan"
from
    COE_PLAN_TABLE_XYZ
where
    STATEMENT_ID = 'COE_XPLAIN'
and :CBO_PLAN > 0
start with id=0
and STATEMENT_ID = 'COE_XPLAIN'
and timestamp = (select max(timestamp)
                 from COE_PLAN_TABLE_XYZ
                 where id=0)
connect by prior id = parent_id
        and prior nvl(statement_id, ' ') = nvl(statement_id, ' ')
        and prior timestamp <= timestamp
order by id,position)
union all
select
    '------------------------------'||
    '-----------------------------------------------------------------------'||
    '-------------------------------------'
from sys.dual
where :CBO_PLAN > 0;
SET recsep wr;

/* VII.b Displays Tables by Join Order                                       */
/* ========================================================================= */
BREAK ON EXECUTION_ORDER_T -
      ON TABLE_NAME_J;
SELECT                 -- VII.b Displays Tables by Join Order
    TABLE_NAME
        TABLE_NAME_J,  -- Tables by Join Order
    TABLE_ONLY,        -- Table only
    INDEX_ONLY,        -- Index only
    INDEX_METHOD,      -- Table/Index Access Method
    EXECUTION_ORDER_T, -- Table execution order
    EXECUTION_ORDER_I  -- Index execution order
FROM
    COE_JOIN_ORDER_XYZ
ORDER BY
    DECODE(EXECUTION_ORDER_T,0,EXECUTION_ORDER_I,EXECUTION_ORDER_T),
    EXECUTION_ORDER_I;

/* VIII. TABLES Section                                                      */
/* ========================================================================= */
PROMPT
PROMPT I. TABLES
PROMPT =========
SELECT                     -- I. TABLES
    CT.TABLE_NUM,          -- Table Number
    AA.OBJECT_ID,          -- Object id
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,       -- Table Owner and Name
    CT.ROWS_COUNT,         -- Count(*) on Table
    ltrim(AT.DEGREE)
        DEGREE,            -- Degree of Parallelism
    ltrim(AT.INSTANCES)
        INSTANCES,         -- Instances
    AT.PARTITIONED,        -- Is this Table partitioned?
    AT.CHAIN_CNT,          -- Count of rows that are chained
    AT.FREELIST_GROUPS,    -- Free List Groups
    AT.FREELISTS,          -- Free Lists
    AT.INI_TRANS,          -- Initial number of transactions
    AT.GLOBAL_STATS        -- YES:Collected for Table  NO:From Partitions
FROM
    ALL_OBJECTS      AA,
    ALL_TABLES       AT,
    COE_TABLES_XYZ   CT    -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = AT.OWNER
AND CT.TABLE_NAME  = AT.TABLE_NAME
AND CT.TABLE_OWNER = AA.OWNER
AND CT.TABLE_NAME  = AA.OBJECT_NAME
AND AA.OBJECT_TYPE = 'TABLE'
AND AA.SUBOBJECT_NAME IS NULL
ORDER BY
    CT.TABLE_NUM;

PROMPT
PROMPT I.a TABLE Partitioning Key Columns
PROMPT ==================================
BREAK ON TABLE_NUM SKIP 1 -
      ON OWNER_TABLE;
SELECT /*+ ALL_ROWS */    -- I.a TABLE Partitioning Key Columns
    CT.TABLE_NUM,         -- Table Number
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,      -- Table Owner and Name
    APKC.COLUMN_POSITION, -- Column Position in Partitioning Key
    APKC.COLUMN_NAME      -- Column Name
FROM
    ALL_PART_KEY_COLUMNS  APKC,
    COE_TABLES_XYZ        CT
WHERE
    CT.TABLE_OWNER      = APKC.OWNER
AND CT.TABLE_NAME       = APKC.NAME
AND CT.PARTITIONED      = 'YES'
AND APKC.OBJECT_TYPE LIKE 'TABLE%'
ORDER BY
    CT.TABLE_NUM,
    APKC.COLUMN_POSITION;

PROMPT
PROMPT I.b TABLE Statistics
PROMPT ====================
CLEAR breaks;
SELECT                     -- I.b TABLE Statistics
    CT.TABLE_NUM,          -- Table Number
    to_char(AT.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,     -- Last Analyzed
    AT.SAMPLE_SIZE,        -- Sample Size used when Alalyzed
    AT.NUM_ROWS,           -- Number of Rows in Table according to Analyze
    ROUND(ABS(CT.ROWS_COUNT-AT.NUM_ROWS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)*100,1)
        DELTA_PERCENT,     -- Delta % = ABS(A-B)/A
    AT.AVG_ROW_LEN,        -- Average Row Length in bytes
    AT.BLOCKS
       USED_BLOCKS,        -- Used Blocks in Table
    AT.EMPTY_BLOCKS,       -- Empty Blocks in Table
    ROUND(AT.AVG_SPACE/:db_block_size*100,3)
       AVG_SPACE_PERCENT,  -- Avg free space per allocated block (percent)
    CT.NUM_IO_FTS,         -- I/O's for FTS
    CEIL(AT.NUM_ROWS/GREATEST(TRUNC((:db_block_size-150-AT.INI_TRANS*23)*
    (1-AT.PCT_FREE/100)/(AT.AVG_ROW_LEN+5)),1))
       T_BLOCKS,           -- Estimated blocks if rebuilt
    CEIL(AT.NUM_ROWS/GREATEST(TRUNC((:db_block_size-150-1*23)*
    (1-10/100)/(AT.AVG_ROW_LEN+5)),1))
       T_BLOCKS2           -- Estimated blocks if rebuilt
FROM
    ALL_TABLES       AT,
    COE_TABLES_XYZ   CT    -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = AT.OWNER
AND CT.TABLE_NAME  = AT.TABLE_NAME
ORDER BY
    CT.TABLE_NUM;
PROMPT
PROMPT Note(*): For accurate values run first coe_fix_stats.sql

PROMPT
PROMPT I.c TABLE Partitions
PROMPT ====================
BREAK ON TABLE_NUM SKIP 1;
SELECT /*+ USE_HASH(ATP) */-- I.c TABLE Partitions
    CT.TABLE_NUM,          -- Table Number
    ATP.PARTITION_POSITION,-- Partition Number
    AA.OBJECT_ID,          -- Object id
    ATP.PARTITION_NAME,    -- Partition Name
    ATP.COMPOSITE,
    ATP.SUBPARTITION_COUNT,-- Subpartitions within Partition
    ATP.CHAIN_CNT,         -- Count of rows that are chained
    ATP.FREELIST_GROUPS,   -- Free List Groups
    ATP.FREELISTS,         -- Free Lists
    ATP.INI_TRANS,         -- Initial number of transactions
    ATP.GLOBAL_STATS,      -- YES:Collected for Table  NO:From Partitions
    ATP.HIGH_VALUE         -- Partition bound value expression
FROM
    ALL_OBJECTS          AA,
    ALL_TAB_PARTITIONS   ATP,
    COE_TABLES_XYZ       CT   -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER     = ATP.TABLE_OWNER
AND CT.TABLE_NAME      = ATP.TABLE_NAME
AND ATP.TABLE_OWNER    = AA.OWNER
AND ATP.TABLE_NAME     = AA.OBJECT_NAME
AND ATP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CT.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE = 'TABLE PARTITION'
ORDER BY
    CT.TABLE_NUM,
    ATP.PARTITION_POSITION;

PROMPT
PROMPT I.d TABLE Partition Statistics
PROMPT ==============================
BREAK ON TABLE_NUM SKIP 1;
COMPUTE SUM LABEL "" OF NUM_ROWS_P USED_BLOCKS EMPTY_BLOCKS -
                        NUM_IO_FTS T_BLOCKS T_BLOCKS2 ON TABLE_NUM;
SELECT /*+ USE_HASH(ATP) */-- I.d TABLE Partition Statistics
    CT.TABLE_NUM,          -- Table Number
    ATP.PARTITION_POSITION,-- Partition Number
    to_char(ATP.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,     -- Last Analyzed
    ATP.SAMPLE_SIZE,       -- Sample Size used when Alalyzed
    ATP.NUM_ROWS
       NUM_ROWS_P,         -- Number of Rows in Table according to Analyze
    ATP.AVG_ROW_LEN,       -- Average Row Length in bytes
    ATP.BLOCKS
       USED_BLOCKS,        -- Used Blocks in Table
    ATP.EMPTY_BLOCKS,      -- Empty Blocks in Table
    ROUND(ATP.AVG_SPACE/:db_block_size*100,3)
       AVG_SPACE_PERCENT,  -- Avg free space per allocated block (percent)
    CEIL(ATP.BLOCKS/:db_file_multiblock_read_count)
       NUM_IO_FTS,         -- I/O's for FTS
    CEIL(ATP.NUM_ROWS/TRUNC((:db_block_size-150-ATP.INI_TRANS*23)*
    (1-ATP.PCT_FREE/100)/(ATP.AVG_ROW_LEN+5)))
       T_BLOCKS,           -- Estimated blocks if rebuilt
    CEIL(ATP.NUM_ROWS/TRUNC((:db_block_size-150-1*23)*
    (1-10/100)/(ATP.AVG_ROW_LEN+5)))
       T_BLOCKS2           -- Estimated blocks if rebuilt
FROM
    ALL_TAB_PARTITIONS  ATP,
    COE_TABLES_XYZ      CT -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = ATP.TABLE_OWNER
AND CT.TABLE_NAME  = ATP.TABLE_NAME
AND CT.PARTITIONED = 'YES'
ORDER BY
    CT.TABLE_NUM,
    ATP.PARTITION_POSITION;
PROMPT
PROMPT Note(*): For accurate values run first coe_fix_stats.sql

PROMPT
PROMPT I.e TABLE Storage Parameters
PROMPT ============================
CLEAR breaks;
CLEAR computes;
SELECT                     -- I.e TABLE Storage Parameters
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME,         -- Table Name
    CT.TABLESPACE_NAME,    -- Tablespace
    AT.PCT_FREE,           -- Minimum percentage of free space per block
    AT.PCT_USED,           -- Minimum percentage of used space per block
    AT.INITIAL_EXTENT,     -- Initial Extent size in bytes
    AT.NEXT_EXTENT,        -- Next Extent size in bytes
    AT.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    AT.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    AT.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    ALL_TABLES        AT,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER  = AT.OWNER
AND CT.TABLE_NAME   = AT.TABLE_NAME
AND CT.PARTITIONED <> 'YES'
ORDER BY
    CT.TABLE_NUM;

PROMPT
PROMPT I.f TABLE Partition Storage Parameters
PROMPT ======================================
BREAK ON TABLE_NUM SKIP 1;
SELECT /*+ USE_HASH(ATP) */-- I.f TABLE Partition Storage Parameters
    CT.TABLE_NUM,          -- Table Number
    ATP.PARTITION_POSITION,-- Partition Number
    ATP.TABLESPACE_NAME,   -- Tablespace
    ATP.PCT_FREE,          -- Minimum percentage of free space per block
    ATP.PCT_USED,          -- Minimum percentage of used space per block
    ATP.INITIAL_EXTENT,    -- Initial Extent size in bytes
    ATP.NEXT_EXTENT,       -- Next Extent size in bytes
    ATP.MIN_EXTENT
        MIN_EXTENTS,       -- Minimum number of Extents for this Table
    ATP.MAX_EXTENT
        MAX_EXTENTS,       -- Maximum number of Extents for this Table
    ATP.PCT_INCREASE       -- Percentage increase size for Next Extent
FROM
    ALL_TAB_PARTITIONS ATP,
    COE_TABLES_XYZ     CT  -- All Tables referenced in Explain Plan
WHERE
    CT.TABLE_OWNER = ATP.TABLE_OWNER
AND CT.TABLE_NAME  = ATP.TABLE_NAME
AND CT.PARTITIONED = 'YES'
ORDER BY
    CT.TABLE_NUM,
    ATP.PARTITION_POSITION;

PROMPT
PROMPT I.g TABLE Segments
PROMPT ==================
CLEAR breaks;
SELECT                     -- I.g.1 TABLE Segments
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,       -- Table Owner and Name
    CS.FREELIST_GROUPS,    -- Free List Groups
    CS.FREELISTS,          -- Free Lists
    CS.INITIAL_EXTENT,     -- Initial Extent size in bytes
    CS.NEXT_EXTENT,        -- Next Extent size in bytes
    CS.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    CS.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    CS.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CS.OWNER
AND CT.TABLE_NAME   = CS.SEGMENT_NAME
AND CT.PARTITIONED <> 'YES'
AND CS.SEGMENT_TYPE = 'TABLE'
ORDER BY
    CT.TABLE_NUM;

SELECT                     -- I.g.2 TABLE Segments
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,       -- Table Owner and Name
    CS.TABLESPACE_NAME,    -- Tablespace
    CS.EXTENTS,            -- Number of Extents in Segment
    CS.BLOCKS,             -- Blocks allocated to Segment
    CS.BYTES,              -- Size in Bytes of allocated Blocks
    ROUND(CS.BYTES/1048576,3)
        MEGABYTES          -- Size in Megabytes of allocated Blocks
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CS.OWNER
AND CT.TABLE_NAME   = CS.SEGMENT_NAME
AND CT.PARTITIONED <> 'YES'
AND CS.SEGMENT_TYPE = 'TABLE'
ORDER BY
    CT.TABLE_NUM;


PROMPT
PROMPT I.h TABLE Partition Segments
PROMPT ============================
BREAK ON TABLE_NUM SKIP 1;
SELECT                     -- I.h.1 TABLE Partition Segments
    CT.TABLE_NUM,          -- Table Number
    CS.PARTITION_NAME,     -- Partition Name
    CS.FREELIST_GROUPS,    -- Free List Groups
    CS.FREELISTS,          -- Free Lists
    CS.INITIAL_EXTENT,     -- Initial Extent size in bytes
    CS.NEXT_EXTENT,        -- Next Extent size in bytes
    CS.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    CS.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    CS.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CS.OWNER
AND CT.TABLE_NAME   = CS.SEGMENT_NAME
AND CT.PARTITIONED  = 'YES'
AND CS.SEGMENT_TYPE = 'TABLE PARTITION'
ORDER BY
    CT.TABLE_NUM,
    CS.PARTITION_NAME;

COMPUTE SUM LABEL "" OF EXTENTS BLOCKS BYTES MEGABYTES ON TABLE_NUM;
SELECT                     -- I.h.2 TABLE Partition Segments
    CT.TABLE_NUM,          -- Table Number
    CS.PARTITION_NAME,     -- Partition Name
    CS.TABLESPACE_NAME,    -- Tablespace
    CS.EXTENTS,            -- Number of Extents in Segment
    CS.BLOCKS,             -- Blocks allocated to Segment
    CS.BYTES,              -- Size in Bytes of allocated Blocks
    ROUND(CS.BYTES/1048576,3)
        MEGABYTES          -- Size in Megabytes of allocated Blocks
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_TABLES_XYZ    CT   -- All Tables referenced in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CS.OWNER
AND CT.TABLE_NAME   = CS.SEGMENT_NAME
AND CT.PARTITIONED  = 'YES'
AND CS.SEGMENT_TYPE = 'TABLE PARTITION'
ORDER BY
    CT.TABLE_NUM,
    CS.PARTITION_NAME;

PROMPT
PROMPT I.i TABLE Extents
PROMPT =================
BREAK ON TABLE_NUM SKIP 1 -
      ON OWNER_TABLE;
COMPUTE SUM LABEL "" OF BLOCKS BYTES MEGABYTES ON TABLE_NUM;
SELECT                     -- I.i TABLE Extents
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME
        OWNER_TABLE,       -- Table Owner and Name
    CE.EXTENT_ID,          -- Extent ID
    CE.FILE_ID,            -- File ID
    CE.BLOCK_ID,           -- Starting Block ID
    CE.BLOCKS,             -- Number of Blocks
    CE.BYTES,              -- Number of Bytes
    ROUND(CE.BYTES/1048576,3)
        MEGABYTES          -- Number of Megabytes
FROM
    COE_EXTENTS_XYZ CE,
    COE_TABLES_XYZ  CT
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CE.OWNER
AND CT.TABLE_NAME   = CE.SEGMENT_NAME
AND CT.PARTITIONED <> 'YES'
AND CE.SEGMENT_TYPE = 'TABLE'
ORDER BY
    CT.TABLE_NUM,
    CT.TABLE_OWNER||'.'||CT.TABLE_NAME,
    CE.EXTENT_ID;

PROMPT
PROMPT I.j TABLE Partition Extents
PROMPT ===========================
BREAK ON TABLE_NUM SKIP 2 -
      ON PARTITION_NAME SKIP 1;
COMPUTE SUM LABEL "" OF BLOCKS BYTES MEGABYTES ON TABLE_NUM PARTITION_NAME;
SELECT                     -- I.j TABLE Partition Extents
    CT.TABLE_NUM,          -- Table Number
    CE.PARTITION_NAME,     -- Partition Name
    CE.EXTENT_ID,          -- Extent ID
    CE.FILE_ID,            -- File ID
    CE.BLOCK_ID,           -- Starting Block ID
    CE.BLOCKS,             -- Number of Blocks
    CE.BYTES,              -- Number of Bytes
    ROUND(CE.BYTES/1048576,3)
        MEGABYTES          -- Number of Megabytes
FROM
    COE_EXTENTS_XYZ CE,
    COE_TABLES_XYZ  CT
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CT.TABLE_OWNER  = CE.OWNER
AND CT.TABLE_NAME   = CE.SEGMENT_NAME
AND CT.PARTITIONED  = 'YES'
AND CE.SEGMENT_TYPE = 'TABLE PARTITION'
ORDER BY
    CT.TABLE_NUM,
    CE.PARTITION_NAME,
    CE.EXTENT_ID;

PROMPT
PROMPT I.k TABLE Triggers
PROMPT ==================
BREAK ON TABLE_NUM SKIP 1;
SELECT /*+ ALL_ROWS */     -- I.k TABLE Triggers
    CT.TABLE_NUM,          -- Table Number
    AT.OWNER||'.'||AT.TRIGGER_NAME
        OWNER_TRIGGER,     -- Trigger Owner and Name
    AT.STATUS,             -- Enabled or Disables
    AT.TRIGGER_TYPE,       -- When the trigger fires
    AT.TRIGGERING_EVENT
FROM
    ALL_TRIGGERS    AT,
    COE_TABLES_XYZ  CT
WHERE
    CT.TABLE_OWNER      = AT.TABLE_OWNER
AND CT.TABLE_NAME       = AT.TABLE_NAME
AND AT.BASE_OBJECT_TYPE = 'TABLE';

PROMPT
PROMPT I.l TABLE/VIEW Policies
PROMPT =======================
CLEAR breaks;
CLEAR computes;
SELECT -- I.l.1 TABLE/VIEW Policies
    CP.OBJECT_OWNER||'.'||CP.OBJECT_NAME OWNER_TABLEVIEW,
    CP.POLICY_NAME,
    CP.SEL,
    CP.INS,
    CP.UPD,
    CP.DEL,
    CP.CHK_OPTION,
    CP.ENABLE,
    CP.PF_OWNER||'.'||CP.PACKAGE||'.'||CP.FUNCTION POLICY_FUNCTION
FROM
    COE_POLICIES_XYZ CP
ORDER BY
    CP.OBJECT_OWNER||'.'||CP.OBJECT_NAME,
    CP.POLICY_NAME;

SELECT DISTINCT -- I.l.2 TABLE/VIEW Policies
    CP.PF_OWNER||'.'||CP.PACKAGE||'.'||CP.FUNCTION POLICY_FUNCTION,
    CP.PB_HEADER
FROM
    COE_POLICIES_XYZ CP;

/* IX. INDEXES Section                                                       */
/* ========================================================================= */
SET recsep off;
CLEAR breaks;
CLEAR computes;
PROMPT
PROMPT II. INDEXES
PROMPT ===========
BREAK ON TABLE_NUM SKIP 1;
SELECT                      -- II.1 INDEXES
    CI.TABLE_NUM,           -- Table Number
    AA.OBJECT_ID,           -- Object id
    CI.IN_PLAN,             -- Used in Plan
    CI.INDEX_OWNER||'.'||CI.INDEX_NAME
        OWNER_INDEX,        -- Index Owner and Name
    CI.ICOLUMNS             -- Indexed Columns
FROM
    ALL_OBJECTS       AA,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;
SET recsep wr;

SELECT                      -- II.2 INDEXES
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    CI.INDEX_OWNER||'.'||CI.INDEX_NAME
        OWNER_INDEX,        -- Index Owner and Name
    substr(AI.INDEX_TYPE,1,14)
        INDEX_TYPE,         -- Index Type
    AI.UNIQUENESS,          -- UNIQUE or NONUNIQUE
    AI.STATUS,              -- VALID or UNUSABLE
    AI.COMPRESSION,         -- Index Compression
    ltrim(AI.DEGREE)
        DEGREE,            -- Degree of Parallelism
    ltrim(AI.INSTANCES)
        INSTANCES,         -- Instances
    AI.PARTITIONED,        -- Is this Table partitioned?
    AI.FREELIST_GROUPS,    -- Free List Groups
    AI.FREELISTS,          -- Free Lists
    AI.INI_TRANS,          -- Initial number of transactions
    AI.GLOBAL_STATS        -- YES:Collected for Table  NO:From Partitions
FROM
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.a INDEX Partitioning Key Columns
PROMPT ===================================
BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1;
SELECT /*+ ALL_ROWS */    -- II.a INDEX Partitioning Key Columns
    CI.TABLE_NUM,         -- Table Number
    CI.INDEX_NUM,         -- Index Number
    CI.INDEX_NAME,        -- Index Name
    APKC.COLUMN_POSITION, -- Column Position in Partitioning Key
    APKC.COLUMN_NAME      -- Column Name
FROM
    ALL_PART_KEY_COLUMNS  APKC,
    COE_INDEXES_XYZ       CI
WHERE
    CI.INDEX_OWNER      = APKC.OWNER
AND CI.INDEX_NAME       = APKC.NAME
AND CI.PARTITIONED      = 'YES'
AND APKC.OBJECT_TYPE LIKE 'INDEX%'
ORDER BY
    CI.TABLE_NUM,         -- Table Number
    CI.INDEX_NUM,         -- Index Number
    APKC.COLUMN_POSITION;

PROMPT
PROMPT II.b INDEX Partitions
PROMPT =====================
BREAK ON TABLE_NUM -
      ON TABLE_NAME -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
SELECT /*+ USE_HASH(AIP) */ -- II.b.1 INDEX Partitions
    CI.TABLE_NUM,           -- Table Number
    CI.TABLE_NAME,          -- Table Name
    CI.INDEX_NUM,           -- Index Number
    CI.INDEX_NAME,          -- Index Name
    AIP.PARTITION_POSITION, -- Partition Number
    AIP.PARTITION_NAME      -- Partition Name
FROM
    ALL_OBJECTS          AA,
    ALL_IND_PARTITIONS   AIP,
    COE_INDEXES_XYZ      CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER     = AIP.INDEX_OWNER
AND CI.INDEX_NAME      = AIP.INDEX_NAME
AND AIP.INDEX_OWNER    = AA.OWNER
AND AIP.INDEX_NAME     = AA.OBJECT_NAME
AND AIP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CI.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE     = 'INDEX PARTITION'
ORDER BY
    CI.TABLE_NUM,
    CI.TABLE_NAME,
    CI.INDEX_NUM,
    CI.INDEX_NAME,
    AIP.PARTITION_POSITION;

BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1;
SELECT /*+ USE_HASH(AIP) */ -- II.b.2 INDEX Partitions
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AIP.PARTITION_POSITION, -- Partition Number
    AA.OBJECT_ID,           -- Object id
    AIP.STATUS,             -- VALID or UNUSABLE
    AIP.COMPRESSION,        -- Index Compression
    AIP.SUBPARTITION_COUNT, -- Subpartitions within Partition
    AIP.FREELIST_GROUPS,    -- Free List Groups
    AIP.FREELISTS,          -- Free Lists
    AIP.INI_TRANS,          -- Initial number of transactions
    AIP.GLOBAL_STATS,       -- YES:Collected for Table  NO:From Partitions
    AIP.HIGH_VALUE          -- Partition bound value expression
FROM
    ALL_OBJECTS          AA,
    ALL_IND_PARTITIONS   AIP,
    COE_INDEXES_XYZ      CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER     = AIP.INDEX_OWNER
AND CI.INDEX_NAME      = AIP.INDEX_NAME
AND AIP.INDEX_OWNER    = AA.OWNER
AND AIP.INDEX_NAME     = AA.OBJECT_NAME
AND AIP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CI.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE     = 'INDEX PARTITION'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AIP.PARTITION_POSITION;

PROMPT
PROMPT II.c INDEX Statistics
PROMPT =====================
BREAK ON TABLE_NUM SKIP 1;
SELECT                      -- II.c INDEX Statistics
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    to_char(AI.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,      -- Last Analyzed
    AI.SAMPLE_SIZE,         -- Sample Size used when Analyzed
    AI.NUM_ROWS NUM_ROWS_I, -- Number of Rows in Index according to Analyze
    AI.DISTINCT_KEYS,       -- Number of Distinct code combinations in Index
    CEIL(AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS))
       INDEX_CARDINALITY,   -- The lower the better.  1 is the best
    AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
       INDEX_SELECTIVITY,   -- Index Selectivity
    ROUND(AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)*100,1)
       INDEX_SEL_PERCENT    -- Index Selectivity
FROM
    ALL_OBJECTS       AA,
    ALL_TABLES        AT,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI    -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.TABLE_OWNER  = AT.OWNER
AND CI.TABLE_NAME   = AT.TABLE_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.d INDEX Partition Statistics
PROMPT ===============================
BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
COMPUTE SUM LABEL "" OF NUM_ROWS_IP DISTINCT_KEYS ON INDEX_NUM;
SELECT /*  USE_HASH(AIP) */ -- II.d INDEX Partition Statistics
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    CI.INDEX_NAME,          -- Index Name
    AIP.PARTITION_POSITION, -- Partition Number
    AA.OBJECT_ID,           -- Object id
    to_char(AIP.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,      -- Last Analyzed
    AIP.SAMPLE_SIZE,        -- Sample Size used when Analyzed
    AIP.NUM_ROWS
        NUM_ROWS_IP,        -- Number of Rows in Part according to Analyze
    AIP.DISTINCT_KEYS,      -- Number of Distinct code combinations in Part
    CEIL(AIP.NUM_ROWS/DECODE(AIP.DISTINCT_KEYS,0,null,AIP.DISTINCT_KEYS))
       PART_CARDINALITY,    -- The lower the better.  1 is the best
    AIP.NUM_ROWS/DECODE(AIP.DISTINCT_KEYS,0,null,AIP.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
       PART_SELECTIVITY     -- Partition Selectivity
FROM
    ALL_OBJECTS          AA,
    ALL_TABLES           AT,
    ALL_IND_PARTITIONS   AIP,
    COE_INDEXES_XYZ      CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER     = AIP.INDEX_OWNER
AND CI.INDEX_NAME      = AIP.INDEX_NAME
AND CI.TABLE_OWNER     = AT.OWNER
AND CI.TABLE_NAME      = AT.TABLE_NAME
AND AIP.INDEX_OWNER    = AA.OWNER
AND AIP.INDEX_NAME     = AA.OBJECT_NAME
AND AIP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CI.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE     = 'INDEX PARTITION'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AIP.PARTITION_POSITION;

PROMPT
PROMPT II.e INDEX Statistics (2nd part)
PROMPT ================================
BREAK ON TABLE_NUM SKIP 1;
SELECT                      -- II.e INDEX Statistics (2nd part)
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    AI.BLEVEL,              -- B*-Tree level (index depth)
    AI.LEAF_BLOCKS,         -- Number of leaf blocks
    AI.AVG_LEAF_BLOCKS_PER_KEY, -- Avg num of leaf blocks per key
    AI.AVG_DATA_BLOCKS_PER_KEY, -- Avg num of data blocks per key
    SUM(ATC.AVG_COL_LEN)    -- 8.1
       AVG_ROW_LEN,         -- 8.1
    AI.CLUSTERING_FACTOR,   -- Between Num Blocks and Num Rows
    CI.NUM_IO_FIRS,         -- I/O's for full index range scan and table acc
    CI.BEP_FTS_FIRS         -- Break even point % between FTS and FIRS
FROM
    ALL_OBJECTS       AA,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
GROUP BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AA.OBJECT_ID,
    CI.INDEX_NAME,
    AI.BLEVEL,
    AI.LEAF_BLOCKS,
    AI.AVG_LEAF_BLOCKS_PER_KEY,
    AI.AVG_DATA_BLOCKS_PER_KEY,
    AI.CLUSTERING_FACTOR,
    CI.NUM_IO_FIRS,
    CI.BEP_FTS_FIRS
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;
PROMPT
PROMPT Note(*): For accurate values run first coe_fix_stats.sql

PROMPT
PROMPT II.f INDEX Partition Statistics (2nd part)
PROMPT ==========================================
BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
COMPUTE SUM LABEL "" OF LEAF_BLOCKS CLUSTERING_FACTOR -
                        NUM_IO_FIRS ON INDEX_NUM;
SELECT /*  USE_HASH(AIP) */      -- II.f INDEX Partition Statistics (2nd part)
    CI.TABLE_NUM,                -- Table Number
    CI.INDEX_NUM,                -- Index Number
    CI.INDEX_NAME,               -- Index Name
    AA.OBJECT_ID,                -- Object id
    AIP.PARTITION_POSITION,      -- Partition Number
    AIP.BLEVEL,                  -- B*-Tree level (index depth)
    AIP.LEAF_BLOCKS,             -- Number of leaf blocks
    AIP.AVG_LEAF_BLOCKS_PER_KEY, -- Avg num of leaf blocks per key
    AIP.AVG_DATA_BLOCKS_PER_KEY, -- Avg num of data blocks per key
    SUM(ATC.AVG_COL_LEN)         -- 8.1
       AVG_ROW_LEN,              -- 8.1
    AIP.CLUSTERING_FACTOR,       -- Between Num Blocks and Num Rows
    CEIL(AIP.BLEVEL+AIP.LEAF_BLOCKS+AIP.CLUSTERING_FACTOR)
       NUM_IO_FIRS               -- I/O's full index range scan and table acc
FROM
    ALL_OBJECTS          AA,
    ALL_TAB_COLUMNS      ATC,
    ALL_IND_COLUMNS      AIC,
    ALL_IND_PARTITIONS   AIP,
    COE_INDEXES_XYZ      CI      -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER     = AIP.INDEX_OWNER
AND CI.INDEX_NAME      = AIP.INDEX_NAME
AND CI.INDEX_OWNER     = AIC.INDEX_OWNER
AND CI.INDEX_NAME      = AIC.INDEX_NAME
AND CI.TABLE_OWNER     = ATC.OWNER
AND CI.TABLE_NAME      = ATC.TABLE_NAME
AND AIC.COLUMN_NAME    = ATC.COLUMN_NAME
AND AIP.INDEX_OWNER    = AA.OWNER
AND AIP.INDEX_NAME     = AA.OBJECT_NAME
AND AIP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CI.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE     = 'INDEX PARTITION'
GROUP BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CI.INDEX_NAME,
    AA.OBJECT_ID,
    AIP.PARTITION_POSITION,
    AIP.BLEVEL,
    AIP.LEAF_BLOCKS,
    AIP.AVG_LEAF_BLOCKS_PER_KEY,
    AIP.AVG_DATA_BLOCKS_PER_KEY,
    AIP.CLUSTERING_FACTOR,
    CEIL(AIP.BLEVEL+AIP.LEAF_BLOCKS+AIP.CLUSTERING_FACTOR)
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CI.INDEX_NAME,
    AA.OBJECT_ID,
    AIP.PARTITION_POSITION;
PROMPT
PROMPT Note(*): For accurate values run first coe_fix_stats.sql

PROMPT
PROMPT II.g INDEX Storage Parameters
PROMPT =============================
BREAK ON TABLE_NUM SKIP 1;
SELECT                     -- II.g INDEX Storage Parameters
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_NAME,         -- Index Name
    CI.TABLESPACE_NAME,    -- Tablespace
    AI.PCT_FREE,           -- Minimum percentage of free space per block
    AI.INITIAL_EXTENT,     -- Initial Extent size in bytes
    AI.NEXT_EXTENT,        -- Next Extent size in bytes
    AI.MIN_EXTENTS,        -- Minimum number of Extents for this Index
    AI.MAX_EXTENTS,        -- Maximum number of Extents for this Index
    AI.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.PARTITIONED <> 'YES'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.h INDEX Partition Storage Parameters
PROMPT =======================================
BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
SELECT /*+ USE_HASH(AIP) */ -- II.h INDEX Partition Storage Parameters
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    CI.INDEX_NAME,          -- Index Name
    AIP.PARTITION_POSITION, -- Partition Number
    AIP.TABLESPACE_NAME,    -- Tablespace
    AIP.PCT_FREE,           -- Minimum percentage of free space per block
    AIP.INITIAL_EXTENT,     -- Initial Extent size in bytes
    AIP.NEXT_EXTENT,        -- Next Extent size in bytes
    AIP.MIN_EXTENT
        MIN_EXTENTS,        -- Minimum number of Extents for this Index
    AIP.MAX_EXTENT
        MAX_EXTENTS,        -- Maximum number of Extents for this Index
    AIP.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    ALL_IND_PARTITIONS AIP,
    COE_INDEXES_XYZ    CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER   = AIP.INDEX_OWNER
AND CI.INDEX_NAME    = AIP.INDEX_NAME
AND CI.PARTITIONED   = 'YES'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AIP.PARTITION_POSITION;

PROMPT
PROMPT II.i Index Segments
PROMPT ===================
BREAK ON TABLE_NUM SKIP 1;
SELECT                     -- II.i.1 Index Segments
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_OWNER||'.'||CI.INDEX_NAME
        OWNER_INDEX,       -- Index Owner and Name
    CS.FREELIST_GROUPS,    -- Free List Groups
    CS.FREELISTS,          -- Free Lists
    CS.INITIAL_EXTENT,     -- Initial Extent size in bytes
    CS.NEXT_EXTENT,        -- Next Extent size in bytes
    CS.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    CS.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    CS.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_INDEXES_XYZ   CI   -- All Indexes on Tables in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CS.OWNER
AND CI.INDEX_NAME   = CS.SEGMENT_NAME
AND CI.PARTITIONED <> 'YES'
AND CS.SEGMENT_TYPE = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

SELECT                     -- II.i.2 Index Segments
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_OWNER||'.'||CI.INDEX_NAME
        OWNER_INDEX,       -- Index Owner and Name
    CS.TABLESPACE_NAME,    -- Tablespace
    CS.EXTENTS,            -- Number of Extents in Segment
    CS.BLOCKS,             -- Blocks allocated to Segment
    CS.BYTES,              -- Size in Bytes of allocated Blocks
    ROUND(CS.BYTES/1048576,3)
        MEGABYTES          -- Size in Megabytes of allocated Blocks
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_INDEXES_XYZ   CI   -- All Indexes on Tables in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CS.OWNER
AND CI.INDEX_NAME   = CS.SEGMENT_NAME
AND CI.PARTITIONED <> 'YES'
AND CS.SEGMENT_TYPE = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.j Index Partition Segments
PROMPT =============================
BREAK ON TABLE_NUM SKIP 2 -
      ON INDEX_NUM SKIP 1;
SELECT                     -- II.j.1 Index Partition Segments
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CS.PARTITION_NAME,     -- Partition Name
    CS.FREELIST_GROUPS,    -- Free List Groups
    CS.FREELISTS,          -- Free Lists
    CS.INITIAL_EXTENT,     -- Initial Extent size in bytes
    CS.NEXT_EXTENT,        -- Next Extent size in bytes
    CS.MIN_EXTENTS,        -- Minimum number of Extents for this Table
    CS.MAX_EXTENTS,        -- Maximum number of Extents for this Table
    CS.PCT_INCREASE        -- Percentage increase size for Next Extent
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_INDEXES_XYZ   CI   -- All Indexes on Tables in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CS.OWNER
AND CI.INDEX_NAME   = CS.SEGMENT_NAME
AND CI.PARTITIONED  = 'YES'
AND CS.SEGMENT_TYPE = 'INDEX PARTITION'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CS.PARTITION_NAME;

COMPUTE SUM LABEL "" OF EXTENTS BLOCKS BYTES MEGABYTES ON TABLE_NUM INDEX_NUM;
SELECT                     -- II.j.2 Index Partition Segments
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CS.PARTITION_NAME,     -- Partition Name
    CS.TABLESPACE_NAME,    -- Tablespace
    CS.EXTENTS,            -- Number of Extents in Segment
    CS.BLOCKS,             -- Blocks allocated to Segment
    CS.BYTES,              -- Size in Bytes of allocated Blocks
    ROUND(CS.BYTES/1048576,3)
        MEGABYTES          -- Size in Megabytes of allocated Blocks
FROM
    COE_SEGMENTS_XYZ  CS,
    COE_INDEXES_XYZ   CI   -- All Indexes on Tables in Explain Plan
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CS.OWNER
AND CI.INDEX_NAME   = CS.SEGMENT_NAME
AND CI.PARTITIONED  = 'YES'
AND CS.SEGMENT_TYPE = 'INDEX PARTITION'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CS.PARTITION_NAME;

PROMPT
PROMPT II.k INDEX Extents
PROMPT ==================
BREAK ON TABLE_NUM SKIP 2 -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
COMPUTE SUM LABEL "" OF BLOCKS BYTES MEGABYTES ON TABLE_NUM INDEX_NUM;
SELECT                     -- II.k INDEX Extents
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_NAME,         -- Index Name
    CE.EXTENT_ID,          -- Extent ID
    CE.FILE_ID,            -- File ID
    CE.BLOCK_ID,           -- Starting Block ID
    CE.BLOCKS,             -- Number of Blocks
    CE.BYTES,              -- Number of Bytes
    ROUND(CE.BYTES/1048576,3)
        MEGABYTES          -- Number of Megabytes
FROM
    COE_EXTENTS_XYZ CE,
    COE_INDEXES_XYZ CI
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CE.OWNER
AND CI.INDEX_NAME   = CE.SEGMENT_NAME
AND CI.PARTITIONED <> 'YES'
AND CE.SEGMENT_TYPE = 'INDEX'
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CE.EXTENT_ID;

PROMPT
PROMPT II.l INDEX Partition Extents
PROMPT ============================
BREAK ON INDEX_NAME SKIP 2 -
      ON PARTITION_NAME SKIP 1;
COMPUTE SUM LABEL "" OF BLOCKS BYTES MEGABYTES ON INDEX_NAME PARTITION_NAME;
SELECT                     -- II.l INDEX Partition Extents
    CI.INDEX_NAME,         -- Index Name
    CE.PARTITION_NAME,     -- Partition Name
    CE.EXTENT_ID,          -- Extent ID
    CE.FILE_ID,            -- File ID
    CE.BLOCK_ID,           -- Starting Block ID
    CE.BLOCKS,             -- Number of Blocks
    CE.BYTES,              -- Number of Bytes
    ROUND(CE.BYTES/1048576,3)
        MEGABYTES          -- Number of Megabytes
FROM
    COE_EXTENTS_XYZ CE,
    COE_INDEXES_XYZ CI
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND CI.INDEX_OWNER  = CE.OWNER
AND CI.INDEX_NAME   = CE.SEGMENT_NAME
AND CI.PARTITIONED  = 'YES'
AND CE.SEGMENT_TYPE = 'INDEX PARTITION'
ORDER BY
    CI.INDEX_NAME,
    CE.PARTITION_NAME,
    CE.EXTENT_ID;

PROMPT
PROMPT II.m INDEX Leaf Blocks Analysis
PROMPT ===============================
BREAK ON TABLE_NUM SKIP 1;
SELECT                      -- II.m INDEX Leaf Blocks Analysis
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    AI.LEAF_BLOCKS,         -- Number of leaf blocks
    CEIL(NVL(AI.NUM_ROWS,0)/TRUNC((:db_block_size-150-AI.INI_TRANS*23)*
    (1-AI.PCT_FREE/100)/(SUM(ATC.AVG_COL_LEN)+10)))
       I_BLOCKS,            -- Leaf blocks if rebuilt
    CEIL(NVL(AI.NUM_ROWS,0)/TRUNC((:db_block_size-150-2*23)*
    (1-0/100)/(SUM(ATC.AVG_COL_LEN)+10)))
       I_BLOCKS2,           -- Leaf blocks if rebuilt
    DECODE(NVL(AI.LEAF_BLOCKS,0),0,0,
    ROUND((AI.LEAF_BLOCKS-CEIL(NVL(AI.NUM_ROWS,0)/
    TRUNC((:db_block_size-150-AI.INI_TRANS*23)*
    (1-AI.PCT_FREE/100)/(SUM(ATC.AVG_COL_LEN)+10))))
    *100/AI.LEAF_BLOCKS))
       I_WASTE,             -- LB waste w/current storage parameters
    DECODE(NVL(AI.LEAF_BLOCKS,0),0,0,
    ROUND((AI.LEAF_BLOCKS-CEIL(NVL(AI.NUM_ROWS,0)/
    TRUNC((:db_block_size-150-2*23)*
    (1-0/100)/(SUM(ATC.AVG_COL_LEN)+10))))
    *100/AI.LEAF_BLOCKS))
       I_WASTE2             -- LB waste w/new storage parameters
FROM
    ALL_OBJECTS       AA,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
GROUP BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    AA.OBJECT_ID,
    CI.INDEX_NAME,
    AI.BLEVEL,
    AI.LEAF_BLOCKS,
    AI.AVG_LEAF_BLOCKS_PER_KEY,
    AI.AVG_DATA_BLOCKS_PER_KEY,
    AI.CLUSTERING_FACTOR,
    AI.NUM_ROWS,
    AI.INI_TRANS,
    AI.PCT_FREE
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;

PROMPT
PROMPT II.n INDEX Partition Leaf Blocks Analysis
PROMPT =========================================
BREAK ON TABLE_NUM -
      ON INDEX_NUM SKIP 1 -
      ON INDEX_NAME;
COMPUTE SUM LABEL "" OF LEAF_BLOCKS I_BLOCKS I_BLOCKS2 ON INDEX_NUM;
SELECT /*  USE_HASH(AIP) */      -- II.n INDEX Partition Leaf Blocks Analysis
    CI.TABLE_NUM,                -- Table Number
    CI.INDEX_NUM,                -- Index Number
    CI.INDEX_NAME,               -- Index Name
    AA.OBJECT_ID,                -- Object id
    AIP.PARTITION_POSITION,      -- Partition Number
    AIP.LEAF_BLOCKS,             -- Number of leaf blocks
    CEIL(NVL(AIP.NUM_ROWS,0)/TRUNC((:db_block_size-150-AIP.INI_TRANS*23)*
    (1-AIP.PCT_FREE/100)/(SUM(ATC.AVG_COL_LEN)+10)))
       I_BLOCKS,                 -- Leaf blocks if rebuilt
    CEIL(NVL(AIP.NUM_ROWS,0)/TRUNC((:db_block_size-150-2*23)*
    (1-0/100)/(SUM(ATC.AVG_COL_LEN)+10)))
       I_BLOCKS2,                -- Leaf blocks if rebuilt
    DECODE(NVL(AIP.LEAF_BLOCKS,0),0,0,
    ROUND((AIP.LEAF_BLOCKS-CEIL(NVL(AIP.NUM_ROWS,0)/
    TRUNC((:db_block_size-150-AIP.INI_TRANS*23)*
    (1-AIP.PCT_FREE/100)/(SUM(ATC.AVG_COL_LEN)+10))))
    *100/AIP.LEAF_BLOCKS))
       I_WASTE,                  -- LB waste w/current storage parameters
    DECODE(NVL(AIP.LEAF_BLOCKS,0),0,0,
    ROUND((AIP.LEAF_BLOCKS-CEIL(NVL(AIP.NUM_ROWS,0)/
    TRUNC((:db_block_size-150-2*23)*
    (1-0/100)/(SUM(ATC.AVG_COL_LEN)+10))))
    *100/AIP.LEAF_BLOCKS))
       I_WASTE2                  -- LB waste w/new storage parameters
FROM
    ALL_OBJECTS          AA,
    ALL_TAB_COLUMNS      ATC,
    ALL_IND_COLUMNS      AIC,
    ALL_IND_PARTITIONS   AIP,
    COE_INDEXES_XYZ      CI      -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER     = AIP.INDEX_OWNER
AND CI.INDEX_NAME      = AIP.INDEX_NAME
AND CI.INDEX_OWNER     = AIC.INDEX_OWNER
AND CI.INDEX_NAME      = AIC.INDEX_NAME
AND CI.TABLE_OWNER     = ATC.OWNER
AND CI.TABLE_NAME      = ATC.TABLE_NAME
AND AIC.COLUMN_NAME    = ATC.COLUMN_NAME
AND AIP.INDEX_OWNER    = AA.OWNER
AND AIP.INDEX_NAME     = AA.OBJECT_NAME
AND AIP.PARTITION_NAME = AA.SUBOBJECT_NAME
AND CI.PARTITIONED     = 'YES'
AND AA.OBJECT_TYPE     = 'INDEX PARTITION'
GROUP BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CI.INDEX_NAME,
    AA.OBJECT_ID,
    AIP.PARTITION_POSITION,
    AIP.BLEVEL,
    AIP.LEAF_BLOCKS,
    AIP.AVG_LEAF_BLOCKS_PER_KEY,
    AIP.AVG_DATA_BLOCKS_PER_KEY,
    AIP.CLUSTERING_FACTOR,
    AIP.NUM_ROWS,
    AIP.INI_TRANS,
    AIP.PCT_FREE
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM,
    CI.INDEX_NAME,
    AA.OBJECT_ID,
    AIP.PARTITION_POSITION;

PROMPT
PROMPT II.o INDEX Drop Candidates
PROMPT ==========================
BREAK ON TABLE_NUM SKIP 1;
SELECT                      -- II.c INDEX Statistics
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    AA.OBJECT_ID,           -- Object id
    CI.INDEX_NAME,          -- Index Name
    CEIL(AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS))
       INDEX_CARDINALITY,   -- The lower the better.  1 is the best
    AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
       INDEX_SELECTIVITY,   -- Index Selectivity
    ROUND(AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)*100,1)
       INDEX_SEL_PERCENT,   -- Index Selectivity
    CI.BEP_FTS_FIRS         -- Break even point % between FTS and FIRS
FROM
    ALL_OBJECTS       AA,
    ALL_TABLES        AT,
    ALL_INDEXES       AI,
    COE_INDEXES_XYZ   CI    -- All Tables referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AI.OWNER
AND CI.INDEX_NAME   = AI.INDEX_NAME
AND CI.TABLE_OWNER  = AT.OWNER
AND CI.TABLE_NAME   = AT.TABLE_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
AND AI.NUM_ROWS/DECODE(AI.DISTINCT_KEYS,0,null,AI.DISTINCT_KEYS)/
    DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)*100 > CI.BEP_FTS_FIRS
ORDER BY
    CI.TABLE_NUM,
    CI.INDEX_NUM;


/* X. COLUMNS Section                                                        */
/* ========================================================================= */
PROMPT
PROMPT III. COLUMNS
PROMPT ============
CLEAR breaks;
CLEAR computes;
BREAK ON TABLE_NUM -
      ON INDEX_NUM -
      ON OBJECT_ID -
      ON INDEX_NAME SKIP 1;
SELECT                     -- III. COLUMNS
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    AA.OBJECT_ID,          -- Object id
    CI.INDEX_NAME,         -- Index Name
    AIC.COLUMN_POSITION,   -- Position within Index
    ATC.COLUMN_ID,         -- Column id
    AIC.COLUMN_NAME,       -- Column Name (ordered by column_position)
    DECODE(ATC.NULLABLE,'N','NOT NULL')
        NULLABLE,          -- NULL or NOT NULL
    ATC.DATA_TYPE||DECODE(ATC.DATA_TYPE,
        'VARCHAR2','('||ATC.DATA_LENGTH||')',
        'CHAR','('||ATC.DATA_LENGTH||')',
        'NUMBER',DECODE(ATC.DATA_PRECISION,NULL,NULL,'('||ATC.DATA_PRECISION||
           DECODE(ATC.DATA_SCALE,NULL,NULL,0,NULL,','||ATC.DATA_SCALE)||')'))
        DATA_TYPE          -- Data Type and length
FROM
    ALL_OBJECTS       AA,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.INDEX_OWNER  = AA.OWNER
AND CI.INDEX_NAME   = AA.OBJECT_NAME
AND AA.OBJECT_TYPE  = 'INDEX'
ORDER BY
   CI.TABLE_NUM,
   CI.INDEX_NUM,
   AIC.COLUMN_POSITION;

PROMPT
PROMPT III.a INDEX COLUMN Statistics
PROMPT =============================
BREAK ON TABLE_NUM -
      ON INDEX_NUM -
      ON INDEX_NAME SKIP 1;
SELECT                     -- III.a INDEX COLUMN Statistics
    CI.TABLE_NUM,          -- Table Number
    CI.INDEX_NUM,          -- Index Number
    CI.INDEX_NAME,         -- Index Name
    AIC.COLUMN_NAME,       -- Column Name (ordered by column_position)
    ATC.NUM_NULLS,         -- Number of Rows with NULLs in this column
    AT.NUM_ROWS - NVL(ATC.NUM_NULLS,0)
        NOT_NULLS,         -- Number of Rows with Value
    ATC.NUM_DISTINCT,      -- Number of Distinct values on this column
    CEIL((AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT))
        COLUMN_CARDINALITY,-- The Lower the better.  1 is the best.
    (AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
        COLUMN_SELECTIVITY,-- Column Selectivity
    ATC.DENSITY            -- Column Density (possible due to Histograms)
FROM
    ALL_TABLES        AT,
    ALL_TAB_COLUMNS   ATC,
    ALL_IND_COLUMNS   AIC,
    COE_INDEXES_XYZ   CI   -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER  = AIC.INDEX_OWNER
AND CI.INDEX_NAME   = AIC.INDEX_NAME
AND CI.TABLE_OWNER  = ATC.OWNER
AND CI.TABLE_NAME   = ATC.TABLE_NAME
AND AIC.COLUMN_NAME = ATC.COLUMN_NAME
AND CI.TABLE_OWNER  = AT.OWNER
AND CI.TABLE_NAME   = AT.TABLE_NAME
ORDER BY
   CI.TABLE_NUM,
   CI.INDEX_NUM,
   AIC.COLUMN_POSITION;

PROMPT
PROMPT III.b INDEX COLUMN Partition Statistics
PROMPT =======================================
BREAK ON TABLE_NUM -
      ON INDEX_NUM -
      ON PARTITION_POSITION SKIP 1;
SELECT                      -- III.b INDEX COLUMN Partition Statistics
    CI.TABLE_NUM,           -- Table Number
    CI.INDEX_NUM,           -- Index Number
    ATP.PARTITION_POSITION, -- Partition Number
    AIC.COLUMN_NAME,        -- Column Name (ordered by column_position)
    APCS.NUM_NULLS,         -- Number of Rows with NULLs in this column
    ATP.NUM_ROWS - NVL(APCS.NUM_NULLS,0)
        NOT_NULLS_P,        -- Number of Rows with Value
    APCS.NUM_DISTINCT,      -- Number of Distinct values on this column
    CEIL((ATP.NUM_ROWS-NVL(APCS.NUM_NULLS,0))/
           DECODE(APCS.NUM_DISTINCT,0,null,APCS.NUM_DISTINCT))
        COLUMN_CARDINALITY, -- The Lower the better.  1 is the best.
    (ATP.NUM_ROWS-NVL(APCS.NUM_NULLS,0))/
           DECODE(APCS.NUM_DISTINCT,0,null,APCS.NUM_DISTINCT)/
           DECODE(ATP.NUM_ROWS,0,null,ATP.NUM_ROWS)
        COLUMN_SELECTIVITY,  -- Column Selectivity
    APCS.DENSITY             -- Column Density (possible due to Histograms)
FROM
    ALL_TAB_PARTITIONS      ATP,
    ALL_PART_COL_STATISTICS APCS,
    ALL_IND_COLUMNS         AIC,
    COE_INDEXES_XYZ         CI  -- All Indexes referenced in Explain Plan
WHERE
    CI.INDEX_OWNER      = AIC.INDEX_OWNER
AND CI.INDEX_NAME       = AIC.INDEX_NAME
AND AIC.TABLE_OWNER     = APCS.OWNER
AND AIC.TABLE_NAME      = APCS.TABLE_NAME
AND AIC.COLUMN_NAME     = APCS.COLUMN_NAME
AND APCS.OWNER          = ATP.TABLE_OWNER
AND APCS.TABLE_NAME     = ATP.TABLE_NAME
AND APCS.PARTITION_NAME = ATP.PARTITION_NAME
AND CI.PARTITIONED      = 'YES'
ORDER BY
   CI.TABLE_NUM,
   CI.INDEX_NUM,
   ATP.PARTITION_POSITION,
   AIC.COLUMN_POSITION;

PROMPT
PROMPT III.c TABLE COLUMN Statistics
PROMPT =============================
CLEAR breaks;
SELECT                     -- III.c.1 TABLE COLUMN Statistics
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME          -- Table Name
FROM
    COE_TABLES_XYZ CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y';

BREAK ON TABLE_NUM SKIP 1 -
      ON TABLE_NAME;
SELECT                     -- III.c.2 TABLE COLUMN Statistics
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME,         -- Table Name
    ATC.COLUMN_ID,         -- Sequence number of column as created
    ATC.COLUMN_NAME,       -- Column Name
    DECODE(ATC.NULLABLE,'N','NOT NULL')
        NULLABLE,          -- NULL or NOT NULL
    ATC.DATA_TYPE||DECODE(ATC.DATA_TYPE,
        'VARCHAR2','('||ATC.DATA_LENGTH||')',
        'CHAR','('||ATC.DATA_LENGTH||')',
        'NUMBER',DECODE(ATC.DATA_PRECISION,NULL,NULL,'('||ATC.DATA_PRECISION||
           DECODE(ATC.DATA_SCALE,NULL,NULL,0,NULL,','||ATC.DATA_SCALE)||')'))
        DATA_TYPE,         -- Data Type and length
    to_char(ATC.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,     -- Last Analyzed
    ATC.SAMPLE_SIZE,       -- Sample Size used when Analyzed
    ATC.AVG_COL_LEN,       -- 8.1 Average column length
    ATC.NUM_BUCKETS,       -- Num. of Buckets for Histograms
    ATC.GLOBAL_STATS       -- YES:Collected for Table  NO:From Partitions
FROM
    ALL_TAB_COLUMNS   ATC,
    COE_TABLES_XYZ    CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y' -- incl_all_cols
AND CT.TABLE_OWNER  = ATC.OWNER
AND CT.TABLE_NAME   = ATC.TABLE_NAME
ORDER BY
    CT.TABLE_NUM,
    ATC.COLUMN_ID;

PROMPT
PROMPT III.d TABLE COLUMN Partition Statistics
PROMPT =======================================
BREAK ON TABLE_NUM -
      ON TABLE_NAME -
      ON PARTITION_POSITION SKIP 1;
SELECT /*  USE_HASH(ATP) */-- III.d TABLE COLUMN Partition Statistics
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME,         -- Table Name
    ATP.PARTITION_POSITION,-- Partition Number
    ATC.COLUMN_ID,         -- Sequence number of column as created
    ATC.COLUMN_NAME,       -- Column Name
    to_char(APCS.LAST_ANALYZED,'YYYYMMDD:HH24MISS')
        LAST_ANALYZED,     -- Last Analyzed
    APCS.SAMPLE_SIZE,      -- Sample Size used when Analyzed
    APCS.AVG_COL_LEN,      -- 8.1 Average column length
    APCS.NUM_BUCKETS       -- Num. of Buckets for Histograms
FROM
    ALL_TAB_PARTITIONS      ATP,
    ALL_PART_COL_STATISTICS APCS,
    ALL_TAB_COLUMNS         ATC,
    COE_TABLES_XYZ          CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y' -- incl_all_cols
AND CT.TABLE_OWNER      = ATC.OWNER
AND CT.TABLE_NAME       = ATC.TABLE_NAME
AND ATC.OWNER           = APCS.OWNER
AND ATC.TABLE_NAME      = APCS.TABLE_NAME
AND ATC.COLUMN_NAME     = APCS.COLUMN_NAME
AND APCS.OWNER          = ATP.TABLE_OWNER
AND APCS.TABLE_NAME     = ATP.TABLE_NAME
AND APCS.PARTITION_NAME = ATP.PARTITION_NAME
AND CT.PARTITIONED      = 'YES'
ORDER BY
    CT.TABLE_NUM,
    ATP.PARTITION_POSITION,
    ATC.COLUMN_ID;

CLEAR breaks;
SELECT
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME          -- Table Name
FROM
    COE_TABLES_XYZ CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y';

PROMPT
PROMPT III.e TABLE COLUMN Statistics (2nd part)
PROMPT ========================================
BREAK ON TABLE_NUM SKIP 1;
SELECT                       -- III.e TABLE COLUMN Statistics (2nd part)
    CT.TABLE_NUM,            -- Table Number
    ATC.COLUMN_ID,           -- Sequence number of column as created
    ATC.COLUMN_NAME,         -- Column Name
    ATC.NUM_NULLS,           -- Number of Rows with NULLs in this column
    AT.NUM_ROWS - NVL(ATC.NUM_NULLS,0)
        NOT_NULLS,           -- Number of Rows with Value
    ATC.NUM_DISTINCT,        -- Number of Distinct values on this column
    CEIL((AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT))
        COLUMN_CARDINALITY,  -- The Lower the better.  1 is the best.
    (AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS)
        COLUMN_SELECTIVITY_2,-- Column Selectivity
    ATC.DENSITY
        DENSITY_2,           -- Column Density (possible due to Histograms)
    (ATC.DENSITY-(AT.NUM_ROWS-NVL(ATC.NUM_NULLS,0))/
           DECODE(ATC.NUM_DISTINCT,0,null,ATC.NUM_DISTINCT)/
           DECODE(AT.NUM_ROWS,0,null,AT.NUM_ROWS))
        DENSITY_MISMATCH     -- Internal Bug
FROM
    ALL_TAB_COLUMNS   ATC,
    ALL_TABLES        AT,
    COE_TABLES_XYZ    CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y' -- incl_all_cols
AND CT.TABLE_OWNER  = AT.OWNER
AND CT.TABLE_NAME   = AT.TABLE_NAME
AND CT.TABLE_OWNER  = ATC.OWNER
AND CT.TABLE_NAME   = ATC.TABLE_NAME
ORDER BY
    CT.TABLE_NUM,
    ATC.COLUMN_ID;

PROMPT
PROMPT III.f TABLE COLUMN Partition Statistics (2nd part)
PROMPT ==================================================
BREAK ON TABLE_NUM -
      ON PARTITION_POSITION SKIP 1;
SELECT /*  USE_HASH(ATP) */   -- III.f TABLE COLUMN Partition Statistics (2nd)
    CT.TABLE_NUM,             -- Table Number
    ATP.PARTITION_POSITION,   -- Partition Number
    ATC.COLUMN_ID,            -- Sequence number of column as created
    ATC.COLUMN_NAME,          -- Column Name
    APCS.NUM_NULLS,           -- Number of Rows with NULLs in this column
    ATP.NUM_ROWS - NVL(APCS.NUM_NULLS,0)
        NOT_NULLS_P,          -- Number of Rows with Value
    APCS.NUM_DISTINCT,        -- Number of Distinct values on this column
    CEIL((ATP.NUM_ROWS-NVL(APCS.NUM_NULLS,0))/
           DECODE(APCS.NUM_DISTINCT,0,null,APCS.NUM_DISTINCT))
        COLUMN_CARDINALITY,   -- The Lower the better.  1 is the best.
    (ATP.NUM_ROWS-NVL(APCS.NUM_NULLS,0))/
           DECODE(APCS.NUM_DISTINCT,0,null,APCS.NUM_DISTINCT)/
           DECODE(ATP.NUM_ROWS,0,null,ATP.NUM_ROWS)
        COLUMN_SELECTIVITY_2, -- Column Selectivity
    APCS.DENSITY
        DENSITY_2,            -- Column Density (possible due to Histograms)
    (APCS.DENSITY-(ATP.NUM_ROWS-NVL(APCS.NUM_NULLS,0))/
           DECODE(APCS.NUM_DISTINCT,0,null,APCS.NUM_DISTINCT)/
           DECODE(ATP.NUM_ROWS,0,null,ATP.NUM_ROWS))
        DENSITY_MISMATCH     -- Internal Bug
FROM
    ALL_TAB_PARTITIONS      ATP,
    ALL_PART_COL_STATISTICS APCS,
    ALL_TAB_COLUMNS         ATC,
    COE_TABLES_XYZ          CT
WHERE
    NVL(substr(upper('&&include_all_columns'),1,1),'Y') = 'Y' -- incl_all_cols
AND CT.TABLE_OWNER      = ATC.OWNER
AND CT.TABLE_NAME       = ATC.TABLE_NAME
AND ATC.OWNER           = APCS.OWNER
AND ATC.TABLE_NAME      = APCS.TABLE_NAME
AND ATC.COLUMN_NAME     = APCS.COLUMN_NAME
AND APCS.OWNER          = ATP.TABLE_OWNER
AND APCS.TABLE_NAME     = ATP.TABLE_NAME
AND APCS.PARTITION_NAME = ATP.PARTITION_NAME
AND CT.PARTITIONED      = 'YES'
ORDER BY
    CT.TABLE_NUM,
    ATP.PARTITION_POSITION,
    ATC.COLUMN_ID;

/* XI. Tablespaces and Datafiles Section                                     */
/* ========================================================================= */
PROMPT
PROMPT IV. TABLESPACES AND DATAFILES
PROMPT =============================
CLEAR breaks;
SELECT -- IV. TABLESPACES AND DATAFILES
    USERNAME,
    NVL(DEFAULT_TABLESPACE,'Not Specified, defaults SYSTEM')
        DEFAULT_TABLESPACE,
    NVL(TEMPORARY_TABLESPACE,'Not Specified, defaults SYSTEM')
        TEMPORARY_TABLESPACE
FROM
    DBA_USERS
WHERE
    USERNAME = USER;

PROMPT
PROMPT IV.a TABLESPACES
PROMPT ================
SELECT -- IV.a TABLESPACES
    TABLESPACE_NAME,
    INITIAL_EXTENT,
    NEXT_EXTENT,
    MIN_EXTENTS,
    MAX_EXTENTS,
    PCT_INCREASE,
    CONTENTS,
    LOGGING,
    EXTENT_MANAGEMENT,
    ALLOCATION_TYPE
FROM
    DBA_TABLESPACES
WHERE
    TABLESPACE_NAME IN
        (SELECT TABLESPACE_NAME
         FROM COE_TABLES_XYZ
         UNION
         SELECT TABLESPACE_NAME
         FROM COE_INDEXES_XYZ
         UNION
         SELECT TABLESPACE_NAME
         FROM COE_SEGMENTS_XYZ
         UNION
         SELECT NVL(DEFAULT_TABLESPACE,'SYSTEM')
         FROM DBA_USERS
         WHERE USERNAME = USER
         UNION
         SELECT NVL(TEMPORARY_TABLESPACE,'SYSTEM')
         FROM DBA_USERS
         WHERE USERNAME = USER)
ORDER BY
    TABLESPACE_NAME;

PROMPT
PROMPT IV.b DATAFILES
PROMPT ==============
BREAK ON TABLESPACE_NAME SKIP 1;
SELECT -- IV.b DATAFILES
    TABLESPACE_NAME,
    FILE_ID,
    BLOCKS,
    MAXBLOCKS,
    AUTOEXTENSIBLE,
    INCREMENT_BY,
    FILE_NAME
FROM
    DBA_DATA_FILES
WHERE
    NVL(substr(upper('&&include_extents'),1,1),'N') = 'Y' -- include_extents?
AND FILE_ID IN
        (SELECT CE.FILE_ID
         FROM COE_EXTENTS_XYZ CE)
ORDER BY
    TABLESPACE_NAME,
    FILE_ID;

/* XII. Histograms Section                                                   */
/* ========================================================================= */
PROMPT
PROMPT V. HISTOGRAMS
PROMPT =============
CLEAR breaks;
SELECT                     -- V. HISTOGRAMS
    CT.TABLE_NUM,          -- Table Number
    CT.TABLE_NAME          -- Table Name
FROM
    COE_TABLES_XYZ  CT;

PROMPT
PROMPT V.a COLUMN HISTOGRAM candidates
PROMPT ===============================
BREAK ON TABLE_NUM -
      ON TABLE_NAME SKIP 1;
SELECT                     -- V.a COLUMN HISTOGRAM candidates
    CHC.TABLE_NUM,         -- Table Number
    CHC.TABLE_NAME,        -- Table Name
    CHC.COLUMN_NAME,       -- Column Name
    CHC.PARTITION,         -- Table Partition
    CHC.HSIZE              -- Number of Buckets (Max)
FROM
    COE_HISTOGRAM_COLS_XYZ CHC
ORDER BY
    CHC.TABLE_NUM,
    CHC.COLUMN_NAME;

PROMPT
PROMPT V.b COLUMN HISTOGRAMS
PROMPT =====================
BREAK ON TABLE_NUM SKIP 1 -
      ON COLUMN_ID -
      ON COLUMN_NAME SKIP 1;
SELECT                     -- V.b COLUMN HISTOGRAMS
    CH.TABLE_NUM,          -- Table Number
    ATC.COLUMN_ID,         -- Column Id
    CH.COLUMN_NAME,        -- Column Name
    CH.ENDPOINT_NUMBER,    -- Bucket
    CH.ENDPOINT_VALUE
        endpoint_value_e,  -- Normalized numeric value (e10)
    DECODE(ATC.DATA_TYPE,'NUMBER',CH.ENDPOINT_VALUE)
        endpoint_value,    -- Normalized numeric value
    DECODE(ATC.DATA_TYPE,'DATE',
    TO_CHAR(TO_DATE(CH.ENDPOINT_JULIAN,'J'),'DD-MON-YYYY'))
        endpoint_value_d,  -- Normalized numeric value (date)
    CH.ENDPOINT_ACTUAL_VALUE -- Normalized actual value
FROM
    ALL_TAB_COLUMNS    ATC,
    COE_HISTOGRAM_COLS_XYZ CHC,
    COE_HISTOGRAMS_XYZ CH
WHERE
    CH.TABLE_NAME   = CHC.TABLE_NAME
AND CH.COLUMN_NAME  = CHC.COLUMN_NAME
AND CH.TABLE_OWNER  = ATC.OWNER
AND CH.TABLE_NAME   = ATC.TABLE_NAME
AND CH.COLUMN_NAME  = ATC.COLUMN_NAME
ORDER BY
    CH.TABLE_NUM,
    ATC.COLUMN_ID,
    CH.ENDPOINT_NUMBER;

/* XIII. v$parameter and product component version Section                   */
/* ========================================================================= */
PROMPT
PROMPT VI. INIT.ORA parameters
PROMPT =======================
PROMPT

PROMPT VI.a Apps 11i - Required and Recommended
PROMPT ========================================
BREAK ON DUMMY1 SKIP 1;
SELECT
    DECODE(REQUIRED,NULL,'2','1')                DUMMY1,
    NAME                                         PNAME,
    DECODE(UPPER(VALUE),NULL,'...',UPPER(VALUE)) PVALUE1,
    DECODE(REQUIRED,NULL,'...',REQUIRED)         PREQUIRED,
    DECODE(RECOMMENDED,NULL,'...',RECOMMENDED)   PRECOMMENDED,
    DECODE(DEFAULTED,NULL,'none',DEFAULTED)      PDEFAULTED
FROM
    COE_PARAMETERS_XYZ
WHERE
    REQUIRED    IS NOT NULL
OR  RECOMMENDED IS NOT NULL
ORDER BY
    DECODE(REQUIRED,NULL,'2','1'),
    NAME;

PROMPT
PROMPT VI.b Other non-default INIT.ORA parameters
PROMPT ==========================================
SELECT
    NAME  PNAME,
    VALUE PVALUE2
FROM
    COE_PARAMETERS_XYZ
WHERE
    REQUIRED    IS NULL
AND RECOMMENDED IS NULL
ORDER BY
    NAME;

PROMPT
PROMPT VII. Product Component Versions
PROMPT ===============================
SELECT -- VII. Product Component Versions
    PRODUCT,
    VERSION,
    STATUS
FROM
    PRODUCT_COMPONENT_VERSION;

/* XIV. Exporting Statistics                                                 */
/* ========================================================================= */
PROMPT
PROMPT VIII. Exporting Statistics
PROMPT ==========================
PROMPT Exporting Stats into staging table COE_STATTAB_XYZ...
PROMPT
DECLARE
        my_table_owner VARCHAR2(30);
        my_table_name  VARCHAR2(30);
        my_stats_owner VARCHAR2(30);
        my_stats_table VARCHAR2(30);
        my_stats_id    VARCHAR2(30);
        cursor C_exp_stats is
           SELECT -- VIII. Exporting Statistics
               TABLE_OWNER, TABLE_NAME
           FROM
               COE_TABLES_XYZ;
BEGIN
   my_stats_table := 'COE_STATTAB_XYZ' ;
   my_stats_id := 'COE_XPLAIN' ;
   SELECT user into my_stats_owner from sys.dual ;
   OPEN C_exp_stats ;
   LOOP
      FETCH C_exp_stats into my_table_owner, my_table_name ;
      EXIT when C_exp_stats%NOTFOUND;
      DBMS_OUTPUT.PUT_LINE('Exported Stats for '||
                           my_table_owner||'.'||my_table_name);
      DBMS_STATS.EXPORT_TABLE_STATS(my_table_owner,  -- From COE_TABLES
                                    my_table_name,   -- From COE_TABLES
                                    NULL,            -- Partition Name
                                    my_stats_table,  -- COE_STATTAB_XYZ
                                    my_stats_id,     -- COE_XPLAIN
                                    TRUE,            -- Cascade
                                    my_stats_owner); -- APPS (usually)
   END LOOP;
   CLOSE C_exp_stats;
END ;
/

/* XV. Finishing Section                                                     */
/* ========================================================================= */

PROMPT
PROMPT coe_statement_&&1 and coe_xplain_&&1 files are complete.
PROMPT
PROMPT Recover the following files, compress them into a single file
PROMPT coexplain.zip and send/upload the resulting coexplain.zip file for
PROMPT further analysis:
PROMPT 1. coe_statement_&&1
PROMPT 2. coe_xplain_&&1
PROMPT 3. All spool files with VIEW names generated on dedicated directory.
PROMPT On NT, files may get created under $ORACLE_HOME/bin.
PROMPT
PROMPT If you wish to print output files nicely, open them in Wordpad or Word.
PROMPT Use File -> Page Setup (menu option) to change Orientation to Landscape.
PROMPT Using same menu option make all 4 Margins 0.2".  Exit this menu option.
PROMPT Do a 'Select All' (Ctrl+A) and change Font to 'Courier New' Size 8.
PROMPT
PROMPT Your Statistics have being exported into table COE_STATTAB_XYZ.
PROMPT If instructed by Support, use the following command from your
PROMPT Operating System prompt to export these Statistics into a file.
PROMPT Use your O/S Oracle account while executing the command below.
PROMPT Generated O/S file COE_STATTAB_XYZ.dmp is BINARY, always FTP as BINARY.
PROMPT
PROMPT # exp apps/apps file=COE_STATTAB_XYZ tables=COE_STATTAB_XYZ
PROMPT
PROMPT If instructed by Support, recover and send raw SQL trace file generated
PROMPT under the udump directory.  Please, do not TKPROF this SQL trace file
PROMPT generated by the coe_xplain.sql script.
PROMPT

BEGIN
    SELECT par.value||'/*'||pro.spid||'*.trc '
      INTO :trace_file_name
      FROM v$mystat    mys,
           v$session   ses,
           v$process   pro,
           v$instance  ins,
           v$parameter par
     WHERE mys.sid   = ses.sid
       AND ses.paddr = pro.addr
       AND par.name  = 'user_dump_dest'
       AND rownum    = 1;

   DBMS_OUTPUT.PUT_LINE('Raw SQL Trace filename: '||:trace_file_name);
END;
/

SPOOL OFF;
/* If you wish to drop staging tables, remove comments from this section     */
-- DROP   TABLE COE_PLAN_TABLE_XYZ;
-- DROP   TABLE COE_JOIN_ORDER_XYZ;
-- DROP   TABLE COE_TABLES_XYZ;
-- DROP   TABLE COE_INDEXES_XYZ;
-- DROP   TABLE COE_SEGMENTS_XYZ;
-- DROP   TABLE COE_EXTENTS_XYZ;
-- DROP   TABLE COE_HISTOGRAMS_XYZ;
-- DROP   TABLE COE_HISTOGRAM_COLS_XYZ;
-- DROP   TABLE COE_POLICIES_XYZ;
-- DROP   TABLE COE_PARAMETERS_XYZ;
-- DROP   TABLE COE_STATTAB_XYZ;
/* Last table stores Stats for objects accessed, you may need to export it   */
SET ver on trims off pages 24 lin 80 feed on numf 9999999999 long 80;
SET sqlp SQL> sqln on recsep wr serveroutput off;
CLEAR COLUMNS BREAKS COMPUTES;
UNDEFINE 1,include_count,include_extents,include_all_columns;
PROMPT
PROMPT Executing coe_view.sql for accessed complex non-mergeable views
PROMPT
START coe_start_view.sql;
PROMPT
COLUMN ended FORMAT A20 HEADING 'coe_xplain.sql ended';
SELECT TO_CHAR(SYSDATE,'YYYY-MM-DD HH24:MI:SS') ENDED FROM SYS.DUAL;
